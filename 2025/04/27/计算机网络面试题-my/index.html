<!DOCTYPE html><html lang="cn" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>计算机网络面试题(my) | XiWei</title><meta name="author" content="XiWei"><meta name="copyright" content="XiWei"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="说一下TCP的三次握手TCP 三次握手 (Three-way Handshake) 是在建立 TCP 连接时，客户端和服务器之间需要进行的三次数据包交换过程。其目的是同步连接双方的序列号和确认号，并交换 TCP 窗口大小信息，以便为可靠的数据传输建立连接。 过程如下：  第一次握手 (SYN)： 客户端（主动发起连接的一方）向服务器发送一个 TCP SYN (Synchronize Sequenc">
<meta property="og:type" content="article">
<meta property="og:title" content="计算机网络面试题(my)">
<meta property="og:url" content="https://xi-weix.github.io/2025/04/27/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E9%9D%A2%E8%AF%95%E9%A2%98-my/index.html">
<meta property="og:site_name" content="XiWei">
<meta property="og:description" content="说一下TCP的三次握手TCP 三次握手 (Three-way Handshake) 是在建立 TCP 连接时，客户端和服务器之间需要进行的三次数据包交换过程。其目的是同步连接双方的序列号和确认号，并交换 TCP 窗口大小信息，以便为可靠的数据传输建立连接。 过程如下：  第一次握手 (SYN)： 客户端（主动发起连接的一方）向服务器发送一个 TCP SYN (Synchronize Sequenc">
<meta property="og:locale">
<meta property="og:image" content="https://xi-weix.github.io/img/%E9%9B%AA%E8%8A%B1.png">
<meta property="article:published_time" content="2025-04-27T12:56:41.000Z">
<meta property="article:modified_time" content="2025-04-28T06:31:01.287Z">
<meta property="article:author" content="XiWei">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://xi-weix.github.io/img/%E9%9B%AA%E8%8A%B1.png"><script type="application/ld+json">{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "计算机网络面试题(my)",
  "url": "https://xi-weix.github.io/2025/04/27/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E9%9D%A2%E8%AF%95%E9%A2%98-my/",
  "image": "https://xi-weix.github.io/img/%E9%9B%AA%E8%8A%B1.png",
  "datePublished": "2025-04-27T12:56:41.000Z",
  "dateModified": "2025-04-28T06:31:01.287Z",
  "author": [
    {
      "@type": "Person",
      "name": "XiWei",
      "url": "https://xi-weix.github.io/"
    }
  ]
}</script><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="https://xi-weix.github.io/2025/04/27/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E9%9D%A2%E8%AF%95%E9%A2%98-my/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox/fancybox.min.css" media="print" onload="this.media='all'"><script>
    (() => {
      
    const saveToLocal = {
      set: (key, value, ttl) => {
        if (!ttl) return
        const expiry = Date.now() + ttl * 86400000
        localStorage.setItem(key, JSON.stringify({ value, expiry }))
      },
      get: key => {
        const itemStr = localStorage.getItem(key)
        if (!itemStr) return undefined
        const { value, expiry } = JSON.parse(itemStr)
        if (Date.now() > expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return value
      }
    }

    window.btf = {
      saveToLocal,
      getScript: (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        Object.entries(attr).forEach(([key, val]) => script.setAttribute(key, val))
        script.onload = script.onreadystatechange = () => {
          if (!script.readyState || /loaded|complete/.test(script.readyState)) resolve()
        }
        script.onerror = reject
        document.head.appendChild(script)
      }),
      getCSS: (url, id) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onload = link.onreadystatechange = () => {
          if (!link.readyState || /loaded|complete/.test(link.readyState)) resolve()
        }
        link.onerror = reject
        document.head.appendChild(link)
      }),
      addGlobalFn: (key, fn, name = false, parent = window) => {
        if (!false && key.startsWith('pjax')) return
        const globalFn = parent.globalFn || {}
        globalFn[key] = globalFn[key] || {}
        globalFn[key][name || Object.keys(globalFn[key]).length] = fn
        parent.globalFn = globalFn
      }
    }
  
      
      const activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      const activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }

      btf.activateDarkMode = activateDarkMode
      btf.activateLightMode = activateLightMode

      const theme = saveToLocal.get('theme')
    
          theme === 'dark' ? activateDarkMode() : theme === 'light' ? activateLightMode() : null
        
      
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        document.documentElement.classList.toggle('hide-aside', asideStatus === 'hide')
      }
    
      
    const detectApple = () => {
      if (/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)) {
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
  
    })()
  </script><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: undefined,
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false,"highlightFullpage":false,"highlightMacStyle":false},
  copy: {
    success: 'Copy Successful',
    error: 'Copy Failed',
    noSupport: 'Browser Not Supported'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  dateSuffix: {
    just: 'Just now',
    min: 'minutes ago',
    hour: 'hours ago',
    day: 'days ago',
    month: 'months ago'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  infinitegrid: {
    js: 'https://cdn.jsdelivr.net/npm/@egjs/infinitegrid/dist/infinitegrid.min.js',
    buttonText: 'Load More'
  },
  isPhotoFigcaption: false,
  islazyloadPlugin: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: '计算机网络面试题(my)',
  isHighlightShrink: false,
  isToc: true,
  pageType: 'post'
}</script><meta name="generator" content="Hexo 7.3.0"></head><body><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url(/img/beach.jpeg);"><nav id="nav"><span id="blog-info"><a class="nav-site-title" href="/"><img class="site-icon" src="/img/%E9%9B%AA%E8%8A%B1.png" alt="Logo"><span class="site-name">XiWei</span></a><a class="nav-page-title" href="/"><span class="site-name">计算机网络面试题(my)</span></a></span><div id="menus"></div></nav><div id="post-info"><h1 class="post-title">计算机网络面试题(my)</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">Created</span><time class="post-meta-date-created" datetime="2025-04-27T12:56:41.000Z" title="Created 2025-04-27 20:56:41">2025-04-27</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">Updated</span><time class="post-meta-date-updated" datetime="2025-04-28T06:31:01.287Z" title="Updated 2025-04-28 14:31:01">2025-04-28</time></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title=""><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">Post Views:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="container post-content" id="article-container"><h4 id="说一下TCP的三次握手"><a href="#说一下TCP的三次握手" class="headerlink" title="说一下TCP的三次握手"></a>说一下TCP的三次握手</h4><p>TCP 三次握手 (Three-way Handshake) 是在建立 TCP 连接时，客户端和服务器之间需要进行的三次数据包交换过程。其目的是<strong>同步连接双方的序列号和确认号</strong>，并<strong>交换 TCP 窗口大小信息</strong>，以便为可靠的数据传输建立连接。</p>
<p><strong>过程如下：</strong></p>
<ol>
<li><strong>第一次握手 (SYN)：</strong><ul>
<li>客户端（主动发起连接的一方）向服务器发送一个 TCP <strong>SYN (Synchronize Sequence Numbers)</strong> 包。</li>
<li>在这个 SYN 包中：<ul>
<li><strong>SYN 标志位</strong>被设置为 1，表示这是一个连接请求报文。</li>
<li>客户端会选择一个<strong>初始序列号 (Initial Sequence Number, ISN)</strong>，通常是随机生成的，并将其放在 SYN 包的<strong>序列号字段</strong>中。</li>
<li>可以包含客户端支持的 TCP 选项，例如最大报文段长度 (Maximum Segment Size, MSS)。</li>
</ul>
</li>
<li><strong>状态变化：</strong> 客户端发送 SYN 包后，进入 <strong>SYN-SENT</strong> 状态，等待服务器的确认。</li>
</ul>
</li>
<li><strong>第二次握手 (SYN + ACK)：</strong><ul>
<li>服务器（被动接受连接的一方）收到客户端发送的 SYN 包后，如果同意建立连接，会发送一个 <strong>SYN + ACK (Synchronize Sequence Numbers + Acknowledgment)</strong> 包作为响应。</li>
<li>在这个 SYN + ACK 包中：<ul>
<li><strong>SYN 标志位</strong>和 <strong>ACK 标志位</strong>都被设置为 1，表示这是一个对 SYN 包的确认，同时也是服务器发起的同步请求。</li>
<li>服务器会选择自己的<strong>初始序列号 (ISN)</strong>，放在 SYN 包的<strong>序列号字段</strong>中。</li>
<li>服务器会将客户端发送的 SYN 包中的序列号加 1 作为<strong>确认号 (Acknowledgment Number)</strong>，放在 ACK 包的确认号字段中，表示已成功接收到客户端的 SYN 包。</li>
<li>可以包含服务器支持的 TCP 选项，例如 MSS。</li>
</ul>
</li>
<li><strong>状态变化：</strong> 服务器发送 SYN + ACK 包后，进入 <strong>SYN-RECEIVED</strong> 状态，等待客户端的确认。</li>
</ul>
</li>
<li><strong>第三次握手 (ACK)：</strong><ul>
<li>客户端收到服务器发送的 SYN + ACK 包后，会发送一个 <strong>ACK (Acknowledgment)</strong> 包作为对服务器 SYN 包的确认。</li>
<li>在这个 ACK 包中：<ul>
<li><strong>ACK 标志位</strong>被设置为 1，表示这是一个确认报文。</li>
<li>客户端会将服务器发送的 SYN 包中的序列号加 1 作为<strong>确认号 (Acknowledgment Number)</strong>，放在 ACK 包的确认号字段中，表示已成功接收到服务器的 SYN + ACK 包。</li>
<li>ACK 包的<strong>序列号</strong>是客户端在第一次握手时发送的 SYN 包的序列号加 1，也可以是后续数据传输的起始序列号。</li>
<li>可以包含要传输的应用层数据（尽管通常情况下，ACK 包不携带实际数据，数据传输在连接建立成功后才开始）。</li>
</ul>
</li>
<li><strong>状态变化：</strong> 客户端发送 ACK 包后，进入 <strong>ESTABLISHED</strong> 状态，TCP 连接建立成功，可以开始进行数据传输。服务器收到客户端的 ACK 包后，也进入 <strong>ESTABLISHED</strong> 状态，TCP 连接建立成功。</li>
</ul>
</li>
</ol>
<p><img src="/2025/04/27/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E9%9D%A2%E8%AF%95%E9%A2%98-my/Snipaste_2025-04-27_21-04-53.png"></p>
<h4 id="为什么需要三次握手？"><a href="#为什么需要三次握手？" class="headerlink" title="为什么需要三次握手？"></a>为什么需要三次握手？</h4><p>在两次握手的情况下，<strong>服务端没有中间状态给客户端来阻止历史连接，导致服务端可能建立一个历史连接，造成资源浪费。</strong></p>
<p>你想想，在两次握手的情况下，服务端在收到 SYN 报文后，就进入 ESTABLISHED 状态，意味着这时可以给对方发送数据，但是客户端此时还没有进入 ESTABLISHED 状态，假设这次是历史连接，客户端判断到此次连接为历史连接，那么就会回 RST 报文来断开连接，而服务端在第一次握手的时候就进入 ESTABLISHED 状态，所以它可以发送数据的，但是它并不知道这个是历史连接，它只有在收到 RST 报文后，才会断开连接。</p>
<p><img src="/2025/04/27/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E9%9D%A2%E8%AF%95%E9%A2%98-my/Snipaste_2025-04-27_21-08-25.png"></p>
<h4 id="TCP的四次挥手过程"><a href="#TCP的四次挥手过程" class="headerlink" title="TCP的四次挥手过程"></a>TCP的四次挥手过程</h4><p><img src="/2025/04/27/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E9%9D%A2%E8%AF%95%E9%A2%98-my/Snipaste_2025-04-27_21-19-09.png"></p>
<p>具体过程：</p>
<ul>
<li>客户端主动调用关闭连接的函数，于是就会发送 FIN 报文，这个 FIN 报文代表客户端不会再发送数据了，进入 FIN_WAIT_1 状态；</li>
<li>服务端收到了 FIN 报文，然后马上回复一个 ACK 确认报文，此时服务端进入 CLOSE_WAIT 状态。在收到 FIN 报文的时候，TCP 协议栈会为 FIN 包插入一个文件结束符 EOF 到接收缓冲区中，服务端应用程序可以通过 read 调用来感知这个 FIN 包，这个 EOF 会被放在<strong>已排队等候的其他已接收的数据之后</strong>，所以必须要得继续 read 接收缓冲区已接收的数据；</li>
<li>接着，当服务端在 read 数据的时候，最后自然就会读到 EOF，接着 <strong>read() 就会返回 0，这时服务端应用程序如果有数据要发送的话，就发完数据后才调用关闭连接的函数，如果服务端应用程序没有数据要发送的话，可以直接调用关闭连接的函数</strong>，这时服务端就会发一个 FIN 包，这个 FIN 报文代表服务端不会再发送数据了，之后处于 LAST_ACK 状态；</li>
<li>客户端接收到服务端的 FIN 包，并发送 ACK 确认包给服务端，此时客户端将进入 TIME_WAIT 状态；</li>
<li>服务端收到 ACK 确认包后，就进入了最后的 CLOSE 状态；</li>
<li>客户端经过 2MSL 时间之后，也进入 CLOSE 状态；</li>
</ul>
<h4 id="为什么4次挥手中间两次不能变成一次？"><a href="#为什么4次挥手中间两次不能变成一次？" class="headerlink" title="为什么4次挥手中间两次不能变成一次？"></a>为什么4次挥手中间两次不能变成一次？</h4><p>服务器收到客户端的 FIN 报文时，内核会马上回一个 ACK 应答报文，但是服务端应用程序可能还有数据要发送，所以并不能马上发送 FIN 报文，而是将发送 FIN 报文的控制权交给服务端应用程序：</p>
<ul>
<li>如果服务端应用程序有数据要发送的话，就发完数据后，才调用关闭连接的函数；</li>
<li>如果服务端应用程序没有数据要发送的话，可以直接调用关闭连接的函数，</li>
</ul>
<p>从上面过程可知，是否要发送第三次挥手的控制权不在内核，而是在被动关闭方（上图的服务端）的应用程序，因为应用程序可能还有数据要发送，由应用程序决定什么时候调用关闭连接的函数，当调用了关闭连接的函数，内核就会发送 FIN 报文了，所以服务端的 ACK 和 FIN 一般都会分开发送。</p>
<h4 id="TCP和UDP的区别是什么"><a href="#TCP和UDP的区别是什么" class="headerlink" title="TCP和UDP的区别是什么"></a>TCP和UDP的区别是什么</h4><p>TCP（Transmission Control Protocol，传输控制协议）和 UDP（User Datagram Protocol，用户数据报协议）是互联网协议族（TCP&#x2F;IP）中传输层的两种核心协议，它们在连接性、可靠性、速度等方面有着显著的区别。</p>
<p><strong>主要区别：</strong></p>
<ul>
<li><p><strong>连接性：</strong></p>
<ul>
<li><strong>TCP：</strong> 面向连接的协议。在数据传输之前，需要通过<strong>三次握手</strong>建立一个可靠的连接，数据传输完毕后需要<strong>四次挥手</strong>断开连接。</li>
<li><strong>UDP：</strong> 无连接的协议。数据发送方无需与接收方建立连接即可直接发送数据报。</li>
</ul>
</li>
<li><p><strong>可靠性：</strong></p>
<ul>
<li><strong>TCP：</strong> 提供可靠的数据传输。它使用<strong>序列号</strong>、<strong>确认应答</strong>、<strong>超时重传</strong>等机制来保证数据包的<strong>有序</strong>、<strong>无丢失</strong>地到达目标主机。</li>
<li><strong>UDP：</strong> 不提供可靠性保证。它只负责简单地发送数据报，不进行数据包的编号、确认或重传，因此可能发生数据丢失、乱序或重复。</li>
</ul>
</li>
<li><p><strong>传输速度：</strong></p>
<ul>
<li><strong>TCP：</strong> 由于需要建立和维护连接、进行可靠性控制，因此传输速度相对较慢。</li>
<li><strong>UDP：</strong> 由于没有连接建立和可靠性保证的开销，传输速度较快，实时性更好。</li>
</ul>
</li>
<li><p><strong>头部开销：</strong></p>
<ul>
<li><strong>TCP：</strong> 头部通常为 20 字节，包含较多的控制信息。</li>
<li><strong>UDP：</strong> 头部只有 8 字节，开销较小。</li>
</ul>
</li>
<li><p><strong>适用场景：</strong></p>
<ul>
<li><p>TCP：</p>
<p> 适用于对数据可靠性要求高的应用，例如：</p>
<ul>
<li>网页浏览 (HTTP&#x2F;HTTPS)</li>
<li>文件传输 (FTP)</li>
<li>电子邮件 (SMTP&#x2F;POP3&#x2F;IMAP)</li>
<li>远程登录 (SSH&#x2F;Telnet)</li>
</ul>
</li>
<li><p>UDP：</p>
<p> 适用于对实时性要求高、对少量数据丢失不敏感的应用，例如：</p>
<ul>
<li>在线游戏</li>
<li>视频&#x2F;音频流媒体</li>
<li>VoIP (网络电话)</li>
<li>DNS (域名系统)</li>
</ul>
</li>
</ul>
</li>
<li><p><strong>流量控制和拥塞控制：</strong></p>
<ul>
<li><strong>TCP：</strong> 具有流量控制和拥塞控制机制，可以根据网络状况动态调整发送速率，避免网络拥塞。</li>
<li><strong>UDP：</strong> 没有流量控制和拥塞控制机制，发送速率恒定，可能导致网络拥塞。</li>
</ul>
</li>
<li><p><strong>数据传输方式：</strong></p>
<ul>
<li><strong>TCP：</strong> 将数据视为一个连续的字节流。</li>
<li><strong>UDP：</strong> 以数据报为单位进行传输，每个数据报都是一个独立的实体。</li>
</ul>
</li>
</ul>
<p><strong>总结：</strong></p>
<p>TCP 注重可靠性，适用于对数据完整性要求高的场景，但传输速度相对较慢。UDP 注重速度和实时性，适用于对少量数据丢失不敏感的场景。选择使用 TCP 还是 UDP 取决于具体的应用需求。</p>
<h4 id="TCP的拥塞控制"><a href="#TCP的拥塞控制" class="headerlink" title="TCP的拥塞控制"></a>TCP的拥塞控制</h4><p>TCP 的拥塞控制是一种机制，旨在防止网络过载，确保网络资源的公平利用，并维持较高的吞吐量。它通过动态调整发送端的发送速率来适应网络状况。TCP 拥塞控制主要依赖于发送端对网络拥塞的<strong>推断</strong>和<strong>响应</strong>。</p>
<p><strong>核心思想：</strong> 发送端维护一个称为<strong>拥塞窗口 (Congestion Window, cwnd)</strong> 的状态变量，该窗口限制了发送端在收到确认 (ACK) 之前可以发送的数据量。拥塞窗口的大小会根据网络状况动态调整。</p>
<p><strong>TCP 拥塞控制的四个主要算法（经典 TCP Reno）：</strong></p>
<ol>
<li><strong>慢启动 (Slow Start)：</strong><ul>
<li>在连接建立之初或发生超时重传后，发送端会进入慢启动阶段。</li>
<li><code>cwnd</code> 的初始值通常设置为一个较小的值（例如 1 个最大报文段大小 MSS）。</li>
<li>每收到一个 ACK，<code>cwnd</code> 就增加一个 MSS。这使得 <code>cwnd</code> 在每个往返时间 (Round-Trip Time, RTT) 内呈指数级增长。</li>
<li>慢启动的目的是快速探测网络的可用带宽，但为了避免突然发送大量数据导致拥塞，会设置一个<strong>慢启动阈值 (Slow Start Threshold, ssthresh)</strong>。</li>
</ul>
</li>
<li><strong>拥塞避免 (Congestion Avoidance)：</strong><ul>
<li>当 <code>cwnd</code> 达到或超过 <code>ssthresh</code> 时，慢启动阶段结束，进入拥塞避免阶段。</li>
<li>在拥塞避免阶段，<code>cwnd</code> 的增长速度变得缓慢，通常是每个 RTT 内 <code>cwnd</code> 增加 1 个 MSS。</li>
<li>这种线性增长的目的是更温和地增加发送速率，避免快速逼近网络容量的边缘。</li>
</ul>
</li>
<li><strong>拥塞发生 (Congestion Detection)：</strong><ul>
<li>TCP 通过以下两种主要方式检测网络拥塞：<ul>
<li><strong>超时重传 (Timeout Retransmission)：</strong> 如果发送端在设定的超时时间内没有收到已发送报文段的 ACK，则认为发生了丢包，很可能是网络拥塞造成的。</li>
<li><strong>快速重传 (Fast Retransmit)：</strong> 当接收端收到失序的报文段时，会立即发送重复的 ACK（通常是前一个期望收到的报文段的 ACK）。如果发送端收到<strong>三个</strong>或以上的重复 ACK，则认为该报文段丢失，很可能是由于网络拥塞。</li>
</ul>
</li>
</ul>
</li>
<li><strong>拥塞控制后采取的动作 (Congestion Response)：</strong><ul>
<li>超时重传发生时：<ul>
<li><code>ssthresh</code> 被设置为当前 <code>cwnd</code> 的一半。</li>
<li><code>cwnd</code> 被重置为初始值（通常是 1 个 MSS），然后重新进入慢启动阶段。这个过程相对激进地降低了发送速率。</li>
</ul>
</li>
<li>快速重传发生时（快速恢复算法）：<ul>
<li><code>ssthresh</code> 被设置为当前 <code>cwnd</code> 的一半。</li>
<li><code>cwnd</code> 被设置为 <code>ssthresh</code> 加上 3 个 MSS（因为收到了三个重复 ACK，可以推测有三个报文段离开了网络）。</li>
<li>进入<strong>快速恢复 (Fast Recovery)</strong> 阶段。</li>
<li>在快速恢复阶段，每收到一个重复 ACK，<code>cwnd</code> 就增加 1 个 MSS。</li>
<li>当收到一个确认了新数据的 ACK 时，退出快速恢复阶段，将 <code>cwnd</code> 设置为当前的 <code>ssthresh</code>，并进入拥塞避免阶段（或继续在拥塞避免阶段线性增长）。快速恢复是一种相对温和的拥塞响应，因为它假设网络中只丢失了少量报文段。</li>
</ul>
</li>
</ul>
</li>
</ol>
<p><strong>总结：</strong></p>
<p>TCP 的拥塞控制是一个动态调整发送速率以适应网络状况的复杂机制。通过慢启动快速探测可用带宽，通过拥塞避免缓慢增加发送速率，并通过检测丢包（超时或快速重传）来判断网络拥塞并采取相应的降低发送速率的措施（如减小拥塞窗口和调整慢启动阈值），TCP 试图在保证网络稳定性的前提下实现高吞吐量。现代 TCP 协议栈中还实现了许多更先进的拥塞控制算法（如 CUBIC、BBR 等），以进一步提升性能和公平性。</p>
<h4 id="描述一下访问一个URL发生的网络过程"><a href="#描述一下访问一个URL发生的网络过程" class="headerlink" title="描述一下访问一个URL发生的网络过程"></a>描述一下访问一个URL发生的网络过程</h4><p>当你在浏览器中输入一个 URL 并按下回车键时，会发生一系列复杂的网络过程，以下是一个详细的描述：</p>
<ol>
<li><strong>DNS 解析 (DNS Resolution)：</strong><ul>
<li>浏览器首先需要将 URL 中的域名（例如 <code>www.example.com</code>）转换为对应的 IP 地址。这个过程称为 DNS 解析。</li>
<li>浏览器会先检查本地缓存中是否有该域名的 IP 地址。</li>
<li>如果本地缓存中没有，浏览器会向本地 DNS 服务器发起 DNS 查询请求。</li>
<li>本地 DNS 服务器可能也缓存了该域名的 IP 地址，如果有则直接返回。</li>
<li>如果本地 DNS 服务器也没有，它会递归地向根 DNS 服务器、顶级域名 (TLD) 服务器（例如 <code>.com</code>）和权威 DNS 服务器查询，直到找到该域名的 IP 地址。</li>
<li>最终，IP 地址会被返回给浏览器。</li>
</ul>
</li>
<li><strong>建立 TCP 连接 (Establishing TCP Connection)：</strong><ul>
<li>一旦浏览器获得了服务器的 IP 地址，它会尝试与服务器建立 TCP 连接。</li>
<li>TCP 是一种面向连接的协议，需要进行三次握手：<ol>
<li>客户端发送 SYN 包到服务器。</li>
<li>服务器回复 SYN + ACK 包。</li>
<li>客户端发送 ACK 包。</li>
</ol>
</li>
<li>三次握手完成后，TCP 连接建立，客户端和服务器可以开始进行数据传输。</li>
</ul>
</li>
<li><strong>发送 HTTP 请求 (Sending HTTP Request)：</strong><ul>
<li>在 TCP 连接建立后，浏览器会向服务器发送一个 HTTP 请求。</li>
<li>HTTP 请求包含了请求方法（例如 GET、POST）、URL 路径、HTTP 协议版本、请求头（例如 User-Agent、Accept、Cookie）和请求体（对于 POST 请求）。</li>
<li>例如，一个简单的 GET 请求可能如下所示：<code>GET /index.html HTTP/1.1Host: www.example.comUser-Agent: Mozilla/5.0 ...Accept: text/html,application/xhtml+xml,...</code></li>
</ul>
</li>
<li><strong>服务器处理请求并返回 HTTP 响应 (Server Processing and Returning HTTP Response)：</strong><ul>
<li>服务器接收到 HTTP 请求后，会根据请求的 URL 路径找到对应的资源（例如 HTML 文件、图片）。</li>
<li>服务器处理请求，并生成一个 HTTP 响应。</li>
<li>HTTP 响应包含了状态码（例如 200 OK、404 Not Found）、响应头（例如 Content-Type、Content-Length、Set-Cookie）和响应体（包含实际的数据，例如 HTML 内容）。</li>
<li>例如，一个成功的 HTTP 响应可能如下所示：<code>HTTP/1.1 200 OKContent-Type: text/htmlContent-Length: 1234&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;&lt;title&gt;Example&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;h1&gt;Hello, World!&lt;/h1&gt;&lt;/body&gt;&lt;/html&gt;</code></li>
</ul>
</li>
<li><strong>浏览器解析 HTML (Browser Parsing HTML)：</strong><ul>
<li>浏览器接收到 HTTP 响应后，会解析响应体中的 HTML 内容。</li>
<li>浏览器会构建一个 DOM (Document Object Model) 树，表示 HTML 文档的结构。</li>
<li>在解析 HTML 的过程中，如果遇到外部资源（例如 CSS 文件、JavaScript 文件、图片），浏览器会再次发起 HTTP 请求获取这些资源。</li>
</ul>
</li>
<li><strong>渲染页面 (Rendering the Page)：</strong><ul>
<li>浏览器使用 CSS 来确定 HTML 元素的样式。</li>
<li>浏览器执行 JavaScript 代码，JavaScript 可以修改 DOM 树和 CSS 样式，从而改变页面的内容和外观。</li>
<li>浏览器根据 DOM 树和 CSS 样式来计算每个元素的位置和大小，这个过程称为布局 (Layout) 或重排 (Reflow)。</li>
<li>浏览器将计算好的元素绘制到屏幕上，这个过程称为绘制 (Paint) 或重绘 (Repaint)。</li>
</ul>
</li>
<li><strong>断开 TCP 连接 (Closing TCP Connection)：</strong><ul>
<li>在数据传输完成后，客户端和服务器可以选择断开 TCP 连接。</li>
<li>TCP 连接的断开需要进行四次挥手：<ol>
<li>客户端发送 FIN 包。</li>
<li>服务器回复 ACK 包。</li>
<li>服务器发送 FIN 包。</li>
<li>客户端回复 ACK 包。</li>
</ol>
</li>
<li>断开连接是可选的，HTTP 1.1 默认使用持久连接 (Persistent Connection)，即在一定时间内保持 TCP 连接，以便复用连接进行多次请求，提高效率。</li>
</ul>
</li>
</ol>
<p>总而言之，访问一个 URL 涉及一系列复杂的网络交互和浏览器处理过程，包括 DNS 解析、TCP 连接建立、HTTP 请求&#x2F;响应、HTML 解析、页面渲染等步骤。这些步骤协同工作，最终将服务器上的资源呈现给用户。</p>
<h4 id="HTTP1-1和HTTP2-0的主要区别是什么"><a href="#HTTP1-1和HTTP2-0的主要区别是什么" class="headerlink" title="HTTP1.1和HTTP2.0的主要区别是什么"></a>HTTP1.1和HTTP2.0的主要区别是什么</h4><p>HTTP&#x2F;2.0 相对于 HTTP&#x2F;1.1 进行了显著的改进，主要目标是<strong>提高性能和效率</strong>，尤其是在现代 Web 应用场景下。以下是它们的主要区别：</p>
<ul>
<li><strong>二进制分帧 (Binary Framing) vs. 文本格式 (Textual Format)：</strong><ul>
<li><strong>HTTP&#x2F;2.0：</strong> 使用二进制格式传输数据。HTTP 消息被分解为更小的帧 (frames)，这些帧采用二进制编码，使得协议解析更高效、更健壮。</li>
<li><strong>HTTP&#x2F;1.1：</strong> 使用基于文本的格式传输数据。消息以文本行的形式发送，解析相对复杂且容易出错。</li>
</ul>
</li>
<li><strong>多路复用 (Multiplexing) vs. 队头阻塞 (Head-of-Line Blocking)：</strong><ul>
<li><strong>HTTP&#x2F;2.0：</strong> 引入了多路复用机制，允许在一个 TCP 连接上<strong>同时发送多个请求和响应</strong>，这些请求和响应被分解为帧交错发送，接收端再根据帧头部的流 ID 进行组装。这消除了 HTTP&#x2F;1.1 中由于单个请求阻塞后续请求的队头阻塞问题，显著提高了并发性能。</li>
<li><strong>HTTP&#x2F;1.1：</strong> 依赖于多个 TCP 连接来实现并发请求。每个请求&#x2F;响应都需要建立一个新的 TCP 连接（或者使用 Keep-Alive 来复用连接，但仍然是串行处理请求队列中的请求，容易发生队头阻塞）。</li>
</ul>
</li>
<li><strong>头部压缩 (Header Compression) vs. 无压缩或简单压缩：</strong><ul>
<li><strong>HTTP&#x2F;2.0：</strong> 使用 <strong>HPACK (Header Compression for HTTP&#x2F;2)</strong> 算法压缩 HTTP 头部。客户端和服务器维护一个共享的头部字段表，对于重复出现的头部字段，只发送索引号，显著减小了头部的大小，降低了网络开销，尤其是在大量小请求的场景下。</li>
<li><strong>HTTP&#x2F;1.1：</strong> 通常不进行头部压缩，或者使用简单的通用压缩方式，效率较低，导致每个请求都携带冗余的头部信息。</li>
</ul>
</li>
<li><strong>服务器推送 (Server Push) vs. 客户端请求：</strong><ul>
<li><strong>HTTP&#x2F;2.0：</strong> 允许服务器在客户端<strong>主动请求之前</strong>，将客户端可能会需要的资源（例如 CSS、JavaScript、图片）“推送”给客户端。这减少了客户端发起额外请求的延迟，提高了页面加载速度。</li>
<li><strong>HTTP&#x2F;1.1：</strong> 只能在客户端明确请求后，服务器才能发送响应。</li>
</ul>
</li>
<li><strong>请求优先级 (Request Prioritization) vs. 无优先级：</strong><ul>
<li><strong>HTTP&#x2F;2.0：</strong> 允许客户端在发送请求时指定请求的优先级。服务器可以根据这些优先级来决定处理和发送响应的顺序，从而优先发送对用户体验更重要的资源。</li>
<li><strong>HTTP&#x2F;1.1：</strong> 请求的优先级没有明确的机制，服务器通常按照接收到的顺序处理请求。</li>
</ul>
</li>
</ul>
<p><strong>总结：</strong></p>
<p>HTTP&#x2F;2.0 通过引入二进制分帧、多路复用、头部压缩和服务器推送等关键特性，显著提升了 Web 应用程序的性能和效率，尤其是在高并发、资源依赖复杂的现代 Web 应用中表现更佳。它在很大程度上解决了 HTTP&#x2F;1.1 存在的性能瓶颈问题。</p>
<h4 id="HTTP的长连接和短连接"><a href="#HTTP的长连接和短连接" class="headerlink" title="HTTP的长连接和短连接"></a>HTTP的长连接和短连接</h4><p>HTTP 的长连接（Persistent Connection 或 Keep-Alive）和短连接（Non-Persistent Connection）是 HTTP&#x2F;1.1 及更高版本中管理 TCP 连接的两种不同方式，它们决定了在一个 TCP 连接上是否可以进行多次 HTTP 请求和响应的交互。</p>
<p><strong>短连接 (Non-Persistent Connection)：</strong></p>
<ul>
<li><strong>工作方式：</strong> 对于每个 HTTP 请求&#x2F;响应对，客户端和服务器之间都会<strong>建立一个新的 TCP 连接</strong>。一旦响应发送完毕，这个 TCP 连接就会被关闭。</li>
<li>过程：<ol>
<li>客户端发起 HTTP 请求，建立 TCP 连接。</li>
<li>服务器处理请求并发送 HTTP 响应。</li>
<li>服务器关闭 TCP 连接。</li>
<li>如果客户端需要再次请求资源，需要重新建立一个新的 TCP 连接。</li>
</ol>
</li>
<li>优点：<ul>
<li>实现简单。</li>
<li>服务器可以更早地释放连接资源，节省系统开销（尤其是在并发连接不高的场景下）。</li>
</ul>
</li>
<li>缺点：<ul>
<li><strong>性能开销大：</strong> 对于一个包含多个资源的网页（例如 HTML、CSS、JavaScript、图片），每个资源的请求都需要建立和关闭一次 TCP 连接，这会带来额外的延迟（三次握手和四次挥手）。</li>
<li><strong>网络拥塞：</strong> 频繁地建立和关闭连接可能会加剧网络拥塞。</li>
</ul>
</li>
</ul>
<p><strong>长连接 (Persistent Connection 或 Keep-Alive)：</strong></p>
<ul>
<li><strong>工作方式：</strong> 在完成一次 HTTP 请求&#x2F;响应后，TCP 连接<strong>不会立即关闭</strong>，而是保持打开状态一段时间。在这个保持期内，客户端和服务器可以在<strong>同一个 TCP 连接上进行多次 HTTP 请求和响应的交互</strong>。</li>
<li>过程：<ol>
<li>客户端发起 HTTP 请求，建立 TCP 连接。</li>
<li>服务器处理请求并发送 HTTP 响应。</li>
<li>连接保持打开状态。</li>
<li>客户端可以在同一个连接上发起后续的 HTTP 请求。</li>
<li>当所有请求都完成或者连接空闲时间超过一定阈值时，连接才会被关闭（由客户端或服务器发起）。</li>
</ol>
</li>
<li>优点：<ul>
<li><strong>减少了 TCP 连接的建立和关闭次数，降低了延迟，提高了性能</strong>，尤其对于包含多个资源的网页加载非常有利。</li>
<li><strong>减少了网络拥塞</strong>。</li>
</ul>
</li>
<li>缺点：<ul>
<li><strong>服务器需要维护连接状态，可能会占用更多的资源</strong>（尤其是在大量长连接存在的情况下）。</li>
<li>如果客户端或服务器在连接保持期间没有活动，连接可能会被中间的网络设备（如防火墙、代理服务器）意外断开。</li>
</ul>
</li>
</ul>
<p><strong>HTTP&#x2F;1.1 的默认行为：</strong></p>
<p>HTTP&#x2F;1.1 默认使用长连接。客户端可以在请求头中显式地使用 <code>Connection: close</code> 来要求服务器在完成本次响应后关闭连接。服务器也可以在响应头中发送 <code>Connection: close</code> 来通知客户端它将在发送完响应后关闭连接。</p>
<p><strong>HTTP&#x2F;1.0 的行为：</strong></p>
<p>HTTP&#x2F;1.0 默认使用短连接。如果需要使用长连接，客户端需要在请求头中显式地添加 <code>Connection: Keep-Alive</code>。</p>
<p><strong>总结：</strong></p>
<p>长连接通过复用 TCP 连接，显著提升了 HTTP 的性能，尤其是在现代 Web 应用中，一个页面通常包含多个资源。它是 HTTP&#x2F;1.1 及更高版本中的主流连接管理方式。短连接在某些特定场景下可能仍然有其用途，例如简单的、一次性的请求。理解这两种连接方式有助于我们更好地理解 HTTP 的工作原理和性能优化。</p>
<h4 id="DNS域名解析的工作流程"><a href="#DNS域名解析的工作流程" class="headerlink" title="DNS域名解析的工作流程"></a>DNS域名解析的工作流程</h4><p>DNS 域名解析是将人类可读的域名（例如 <code>www.example.com</code>）转换为计算机网络中用于识别和寻址服务器的 IP 地址（例如 <code>192.0.2.1</code>）的过程。其工作流程通常涉及以下步骤：</p>
<ol>
<li><strong>客户端发起查询 (DNS Resolver Initiation)：</strong><ul>
<li>当用户在浏览器中输入一个 URL 或应用程序需要访问一个域名时，DNS 解析过程开始。用户的计算机或设备上的 DNS 客户端（也称为 DNS 解析器）会发起一个 DNS 查询请求。</li>
</ul>
</li>
<li><strong>查询本地 DNS 缓存 (Local DNS Cache Check)：</strong><ul>
<li>DNS 客户端首先检查本地缓存中是否存在该域名对应的 IP 地址。如果之前已经解析过该域名，并且缓存条目尚未过期（由 TTL，Time-To-Live 值决定），则直接从缓存中获取 IP 地址并返回，解析过程结束。</li>
</ul>
</li>
<li><strong>查询本地 DNS 服务器 (Querying the Local DNS Server)：</strong><ul>
<li>如果本地缓存中没有找到对应的 IP 地址，DNS 客户端会将查询请求发送给配置的本地 DNS 服务器（通常由用户的互联网服务提供商 ISP 提供，或在网络设置中手动配置）。这是一个<strong>递归查询</strong>。</li>
</ul>
</li>
<li><strong>本地 DNS 服务器的递归查询 (Recursive Query by Local DNS Server)：</strong><ul>
<li>本地 DNS 服务器收到客户端的查询请求后，也会首先检查其本地缓存。如果找到对应的 IP 地址，则直接返回给客户端。</li>
<li>如果本地 DNS 服务器的缓存中也没有，它会代表客户端发起一系列的<strong>迭代查询</strong>，以找到负责该域名的权威 DNS 服务器。</li>
</ul>
</li>
<li><strong>迭代查询过程 (Iterative Query Process)：</strong><ul>
<li><strong>查询根域名服务器 (.)：</strong> 本地 DNS 服务器首先向根域名服务器发送查询请求，询问负责顶级域名（例如 <code>.com</code>、<code>.org</code>、<code>.net</code>）的顶级域名服务器的地址。</li>
<li><strong>查询顶级域名服务器 (.TLD)：</strong> 根域名服务器返回负责该顶级域名的 TLD 服务器的地址。本地 DNS 服务器然后向该 TLD 服务器发送查询请求，询问负责该二级域名（例如 <code>example.com</code>）的权威域名服务器的地址。</li>
<li><strong>查询权威域名服务器 (Authoritative DNS Server)：</strong> TLD 服务器返回负责该域名的权威域名服务器的地址。本地 DNS 服务器最后向该权威域名服务器发送查询请求，询问 <code>www.example.com</code> 对应的 IP 地址。</li>
</ul>
</li>
<li><strong>权威 DNS 服务器响应 (Authoritative DNS Server Response)：</strong><ul>
<li>权威 DNS 服务器在其管理的域名记录中查找 <code>www.example.com</code> 对应的 IP 地址，并将该 IP 地址封装在 DNS 响应报文中返回给本地 DNS 服务器。</li>
</ul>
</li>
<li><strong>本地 DNS 服务器响应客户端 (Local DNS Server Response to Client)：</strong><ul>
<li>本地 DNS 服务器接收到权威 DNS 服务器返回的 IP 地址后，会将该 IP 地址缓存起来（以便下次查询相同的域名时可以直接使用），并将该 IP 地址返回给发起查询的 DNS 客户端。</li>
</ul>
</li>
<li><strong>客户端使用 IP 地址 (Client Uses IP Address)：</strong><ul>
<li>DNS 客户端收到 IP 地址后，会将其提供给发起请求的应用程序（例如浏览器），应用程序就可以使用该 IP 地址与目标服务器建立连接，进行后续的网络通信（例如发起 HTTP 请求）。</li>
</ul>
</li>
</ol>
<p><strong>总结：</strong></p>
<p>DNS 域名解析是一个分层查询的过程，通常涉及本地缓存、本地 DNS 服务器以及一系列的根、顶级和权威 DNS 服务器的协作。本地 DNS 服务器扮演着递归解析器的角色，代表客户端完成整个查询过程，最终将域名解析为 IP 地址。</p>
<h4 id="token，session，cookie的区别？"><a href="#token，session，cookie的区别？" class="headerlink" title="token，session，cookie的区别？"></a>token，session，cookie的区别？</h4><ul>
<li>session存储于服务器，可以理解为一个状态列表，拥有一个唯一识别符号sessionId，通常存放于cookie中。服务器收到cookie后解析出sessionId，再去session列表中查找，才能找到相应session，依赖cookie。</li>
<li>cookie类似一个令牌，装有sessionId，存储在客户端，浏览器通常会自动添加。</li>
<li>token也类似一个令牌，无状态，用户信息都被加密到token中，服务器收到token后解密就可知道是哪个用户，需要开发者手动添加。</li>
</ul>
<h4 id="JWT是什么"><a href="#JWT是什么" class="headerlink" title="JWT是什么"></a>JWT是什么</h4><p>JWT (JSON Web Token) 是一种<strong>开放标准 (RFC 7519)</strong>，它定义了一种简洁且自包含的方式，用于在通信双方之间安全地传输信息，这些信息可以被验证和信任，因为它们是经过数字签名的。</p>
<p><strong>核心概念：</strong></p>
<ul>
<li><strong>简洁 (Compact)：</strong> JWT 非常小巧，易于通过 URL 参数、HTTP 请求头或 POST 请求体进行传输。</li>
<li><strong>自包含 (Self-contained)：</strong> JWT 包含了所有必要的信息，接收方无需查询额外的数据库或其他来源即可验证令牌的真实性和获取其中的声明信息。</li>
<li><strong>安全 (Secure)：</strong> JWT 可以使用密钥（HMAC 算法）或公钥&#x2F;私钥对（RSA 或 ECDSA 算法）进行签名，确保令牌的完整性和发送者的身份。</li>
</ul>
<p><strong>JWT 的结构：</strong></p>
<p>一个 JWT 实际上是一个包含三个 Base64 编码部分的字符串，它们之间用英文句点 (<code>.</code>) 分隔：</p>
<ol>
<li><p><strong>头部 (Header)：</strong> 包含了关于令牌的元数据，通常是一个 JSON 对象，描述了所使用的签名算法 (<code>alg</code>) 和令牌类型 (<code>typ</code>)。例如：</p>
<p>JSON<code>&#123;  &quot;alg&quot;: &quot;HS256&quot;,  &quot;typ&quot;: &quot;JWT&quot;&#125;</code></p>
<p>这个 JSON 对象会被 Base64Url 编码形成 JWT 的第一部分。</p>
</li>
<li><p><strong>载荷 (Payload)：</strong> 包含了实际要传输的信息（声明，claims）。这些声明可以是<strong>预定义 (registered)</strong> 的（例如 <code>iss</code> - issuer, <code>exp</code> - expiration time, <code>sub</code> - subject, <code>aud</code> - audience, <code>iat</code> - issued at），也可以是<strong>公共 (public)</strong> 的（由使用者自定义），或者是<strong>私有 (private)</strong> 的（在通信双方之间约定好的）。例如：</p>
<p>JSON<code>&#123;  &quot;sub&quot;: &quot;user123&quot;,  &quot;name&quot;: &quot;John Doe&quot;,  &quot;admin&quot;: true,  &quot;iat&quot;: 1678886400,  &quot;exp&quot;: 1678972800&#125;</code></p>
<p>这个 JSON 对象也会被 Base64Url 编码形成 JWT 的第二部分。<strong>注意：虽然载荷是 Base64 编码的，但它并没有加密，因此不应该在载荷中存放敏感信息。</strong></p>
</li>
<li><p><strong>签名 (Signature)：</strong> 用于验证令牌的完整性和发送者的身份。签名是通过将头部和载荷组合在一起，使用头部中指定的算法和密钥进行哈希运算生成的。</p>
<ul>
<li>如果使用 HMAC 算法，则需要一个共享的密钥。</li>
<li>如果使用 RSA 或 ECDSA 算法，则需要发送者的私钥进行签名，接收者可以使用对应的公钥进行验证。</li>
<li>例如，使用 HMAC SHA-256 算法的签名过程可能如下：<code>HMACSHA256(  base64UrlEncode(header) + &quot;.&quot; +  base64UrlEncode(payload),  secret)</code></li>
</ul>
<p>签名结果也会进行 Base64Url 编码形成 JWT 的第三部分。</p>
</li>
</ol>
<p><strong>JWT 的工作流程：</strong></p>
<ol>
<li><strong>认证 (Authentication)：</strong> 客户端向服务器提供凭据（例如用户名和密码）。</li>
<li><strong>生成 JWT：</strong> 服务器验证凭据成功后，会创建一个包含用户身份信息和其他必要声明的 JWT，并使用密钥对 JWT 进行签名。</li>
<li><strong>返回 JWT：</strong> 服务器将生成的 JWT 返回给客户端。</li>
<li><strong>存储 JWT：</strong> 客户端通常会将 JWT 存储在本地（例如 Local Storage、Session Storage、Cookie）或内存中。</li>
<li><strong>授权 (Authorization)：</strong> 客户端在后续的请求中，会将 JWT 放在 HTTP 请求头（通常是 <code>Authorization</code> 字段，使用 <code>Bearer</code> 方案）或其他地方发送给服务器。</li>
<li><strong>验证 JWT：</strong> 服务器接收到 JWT 后，会使用相同的密钥（或公钥）验证 JWT 的签名，确保令牌没有被篡改，并且是合法的。</li>
<li><strong>提取信息：</strong> 如果签名验证通过，服务器可以从 JWT 的载荷中安全地提取用户信息和其他声明，用于进行授权或其他操作，而无需再次查询数据库。</li>
</ol>
<p><strong>JWT 的应用场景：</strong></p>
<ul>
<li><strong>身份验证 (Authentication)：</strong> 最常见的用途，用于验证用户的身份，一旦用户登录，后续请求可以通过 JWT 来进行身份识别，无需每次都重新登录。</li>
<li><strong>授权 (Authorization)：</strong> 用于确定用户是否有权限访问特定的资源或执行特定的操作。JWT 的载荷中可以包含用户的角色和权限信息。</li>
<li><strong>信息交换 (Information Exchange)：</strong> 由于 JWT 是自包含的，可以在不同的服务之间安全地传输信息。</li>
</ul>
<p>总而言之，JWT 提供了一种安全、简洁、自包含的方式来传递和验证信息，特别适用于分布式系统和微服务架构中的身份验证和授权场景。</p>
<h4 id="token-session-cookie的区别"><a href="#token-session-cookie的区别" class="headerlink" title="token, session, cookie的区别"></a>token, session, cookie的区别</h4><p>Token、Session 和 Cookie 是 Web 开发中用于<strong>管理用户状态和进行身份验证&#x2F;授权</strong>的常见概念，但它们在工作原理、存储位置和安全性等方面存在显著的区别。</p>
<p><strong>Cookie：</strong></p>
<ul>
<li><strong>定义：</strong> Cookie 是一小段文本数据，由服务器发送到用户的浏览器并存储在用户的计算机上。当用户再次访问同一网站时，浏览器会将这些 Cookie 附加到 HTTP 请求中发送回服务器。</li>
<li><strong>目的：</strong> 用于在无状态的 HTTP 协议上<strong>存储和维护用户的状态信息</strong>。例如，记住用户的登录状态、购物车内容、偏好设置等。</li>
<li><strong>存储位置：</strong> 存储在<strong>客户端（用户的浏览器）</strong>。</li>
<li><strong>生命周期：</strong> 可以通过服务器设置过期时间，可以是会话级别（浏览器关闭后失效）或持久化存储在硬盘上。</li>
<li>安全性：<ul>
<li>相对较低，容易受到跨站脚本攻击 (XSS) 和跨站请求伪造 (CSRF) 攻击。</li>
<li>可以通过设置 <code>HttpOnly</code> 标志来防止 JavaScript 访问 Cookie，从而缓解 XSS 攻击。</li>
<li>可以通过设置 <code>Secure</code> 标志来确保 Cookie 只在 HTTPS 连接下传输，防止中间人窃听。</li>
<li><code>SameSite</code> 属性可以限制 Cookie 在跨站请求中的发送，提高 CSRF 防御能力。</li>
</ul>
</li>
<li><strong>大小限制：</strong> 每个 Cookie 的大小和每个域名的 Cookie 数量都有限制。</li>
</ul>
<p><strong>Session：</strong></p>
<ul>
<li><strong>定义：</strong> Session 是服务器端用于<strong>存储用户会话信息</strong>的机制。当用户成功登录后，服务器会创建一个与该用户关联的 Session，并为该 Session 分配一个唯一的 <strong>Session ID</strong>。</li>
<li><strong>目的：</strong> 用于<strong>跟踪用户的登录状态和活动</strong>，在用户与网站进行多次交互期间保持用户的状态。</li>
<li><strong>存储位置：</strong> 存储在<strong>服务器端</strong>，例如内存、数据库或文件系统。</li>
<li><strong>生命周期：</strong> 通常与用户的登录会话相关联，当用户注销或会话超时后失效。</li>
<li>安全性：<ul>
<li>相对较高，因为敏感的用户状态信息存储在服务器端，客户端只持有 Session ID。</li>
<li>Session ID 通常通过 Cookie 的方式发送给客户端存储，因此仍然需要注意 Cookie 的安全问题。</li>
<li>可以通过定期更换 Session ID、设置过期时间、使用 HTTPS 等方式提高 Session 的安全性.</li>
</ul>
</li>
<li><strong>扩展性：</strong> 在分布式环境下，Session 的管理需要考虑如何共享或同步 Session 数据。</li>
</ul>
<p><strong>Token (通常指 JWT - JSON Web Token)：</strong></p>
<ul>
<li><strong>定义：</strong> Token 是一种<strong>无状态的</strong>安全凭证，用于表示用户的身份和授权信息。最常见的形式是 JWT。</li>
<li><strong>目的：</strong> 用于<strong>身份验证和授权</strong>，允许服务器验证用户的身份，并确定用户可以访问哪些资源。</li>
<li><strong>存储位置：</strong> 可以存储在客户端（例如 Local Storage、Session Storage、Cookie）或通过其他方式在客户端和服务器之间传递（例如 HTTP 请求头）。</li>
<li><strong>生命周期：</strong> 由 Token 本身包含的 <code>exp</code> (expiration time) 声明控制，过期后需要重新获取。也可以通过刷新 Token 的机制延长有效期。</li>
<li>安全性：<ul>
<li>如果正确实现和使用，Token 可以提供较高的安全性。</li>
<li>通过数字签名（例如使用密钥或公钥&#x2F;私钥对）保证 Token 的完整性和不可篡改性。</li>
<li><strong>无状态性</strong> 减少了服务器端的存储压力，更易于在分布式环境下扩展。</li>
<li>需要防范 XSS 攻击窃取 Token，因此存储在 Cookie 中时需要设置 <code>HttpOnly</code> 和 <code>Secure</code> 标志。</li>
<li>对于敏感操作，可能需要使用短期 Token 或结合其他验证机制。</li>
</ul>
</li>
</ul>
<p><strong>总结对比：</strong></p>
<table>
<thead>
<tr>
<th><strong>特征</strong></th>
<th><strong>Cookie</strong></th>
<th><strong>Session</strong></th>
<th><strong>Token (JWT)</strong></th>
</tr>
</thead>
<tbody><tr>
<td><strong>存储位置</strong></td>
<td>客户端 (浏览器)</td>
<td>服务器端</td>
<td>客户端 (推荐但需安全存储) 或请求头等</td>
</tr>
<tr>
<td><strong>状态</strong></td>
<td>可以存储状态信息</td>
<td>服务器端维护用户状态</td>
<td>无状态 (自包含用户信息)</td>
</tr>
<tr>
<td><strong>安全性</strong></td>
<td>较低 (易受 XSS&#x2F;CSRF 攻击，需采取安全措施)</td>
<td>相对较高 (敏感信息在服务器端)</td>
<td>较高 (通过签名保证完整性，但需防范客户端泄露)</td>
</tr>
<tr>
<td><strong>生命周期</strong></td>
<td>服务器控制 (通过过期时间)</td>
<td>服务器控制 (通常与用户会话关联)</td>
<td>Token 自身包含过期时间</td>
</tr>
<tr>
<td><strong>用途</strong></td>
<td>存储用户状态、跟踪用户、简单身份识别</td>
<td>跟踪用户会话、管理用户状态、身份验证</td>
<td>身份验证、授权、信息传递</td>
</tr>
<tr>
<td><strong>扩展性</strong></td>
<td>影响不大</td>
<td>分布式环境下需要特殊处理</td>
<td>良好 (无状态，易于水平扩展)</td>
</tr>
<tr>
<td><strong>大小限制</strong></td>
<td>有 (每个 Cookie 和每个域名数量有限制)</td>
<td>服务器端存储，大小通常不是主要限制</td>
<td>相对较小 (需要考虑传输效率)</td>
</tr>
</tbody></table>
<p>选择使用 Cookie、Session 还是 Token 取决于具体的应用场景、安全需求和架构设计。在现代 Web 应用中，基于 Token 的身份验证（如 JWT）因其无状态性和良好的扩展性而越来越流行，但 Cookie 和 Session 在某些场景下仍然扮演着重要的角色。通常，Session ID 会通过 Cookie 的方式在客户端和服务器之间传递。</p>
<h4 id="HTTP1-0到2-0的区别"><a href="#HTTP1-0到2-0的区别" class="headerlink" title="HTTP1.0到2.0的区别"></a>HTTP1.0到2.0的区别</h4><p>HTTP&#x2F;1.0版本主要增加以下几点:</p>
<ul>
<li>增加了HEAD、POST等新方法。</li>
<li>增加了响应状态码。</li>
<li>引入了头部，即请求头和响应头。</li>
<li>在请求中加入了HTTP版本号。</li>
<li>引入了Content-Type，使得传输的数据不再限于文本。</li>
</ul>
<p>HTTP&#x2F;1.1版本主要增加以下几点:</p>
<ul>
<li>新增了连接管理即keepalive，允许持久连接。</li>
<li>支持pipeline，无需等待前面的请求响应，即可发送第二次请求。</li>
<li>允许响应数据分块(chunked)，即响应的时候不标明Content-Length，客户端就无法断开连接，直到收到服务端的EOF，利于传输大文件。</li>
<li>新增缓存的控制和管理。</li>
<li>加入了Host头，用在你一台机子部署了多个主机，然后多个域名解析又是同一个IP，此时加入了Host头就可以判断你到底是要访问哪个主机。</li>
</ul>
<p>HTTP&#x2F;2版本主要增加以下几点:</p>
<ul>
<li>是二进制协议，不再是纯文本。</li>
<li>支持一个TCP连接发起多请求，移除了pipeline。</li>
<li>利用HPACK压缩头部，减少数据传输量。</li>
<li>允许服务端主动推送数据。</li>
</ul>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta"><i class="fas fa-circle-user fa-fw"></i>Author: </span><span class="post-copyright-info"><a href="https://xi-weix.github.io">XiWei</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta"><i class="fas fa-square-arrow-up-right fa-fw"></i>Link: </span><span class="post-copyright-info"><a href="https://xi-weix.github.io/2025/04/27/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E9%9D%A2%E8%AF%95%E9%A2%98-my/">https://xi-weix.github.io/2025/04/27/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E9%9D%A2%E8%AF%95%E9%A2%98-my/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta"><i class="fas fa-circle-exclamation fa-fw"></i>Copyright Notice: </span><span class="post-copyright-info">All articles on this blog are licensed under <a target="_blank" rel="noopener" href="https://creativecommons.org/licenses/by-nc-sa/4.0/">CC BY-NC-SA 4.0</a> unless otherwise stated.</span></div></div><div class="tag_share"><div class="post-share"><div class="social-share" data-image="/img/%E9%9B%AA%E8%8A%B1.png" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"></nav></div><div class="aside-content" id="aside-content"><div class="card-widget card-info text-center"><div class="avatar-img"><img src="/img/%E9%9B%AA%E8%8A%B1.png" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info-name">XiWei</div><div class="author-info-description"></div><div class="site-data"><a href="/archives/"><div class="headline">Articles</div><div class="length-num">23</div></a><a href="/tags/"><div class="headline">Tags</div><div class="length-num">1</div></a><a href="/categories/"><div class="headline">Categories</div><div class="length-num">0</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/Xi-WeiX"><i class="fab fa-github"></i><span>Follow Me</span></a></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>Announcement</span></div><div class="announcement_content">This is my Blog</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>Contents</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%AF%B4%E4%B8%80%E4%B8%8BTCP%E7%9A%84%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B"><span class="toc-number">1.</span> <span class="toc-text">说一下TCP的三次握手</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E9%9C%80%E8%A6%81%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B%EF%BC%9F"><span class="toc-number">2.</span> <span class="toc-text">为什么需要三次握手？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#TCP%E7%9A%84%E5%9B%9B%E6%AC%A1%E6%8C%A5%E6%89%8B%E8%BF%87%E7%A8%8B"><span class="toc-number">3.</span> <span class="toc-text">TCP的四次挥手过程</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%884%E6%AC%A1%E6%8C%A5%E6%89%8B%E4%B8%AD%E9%97%B4%E4%B8%A4%E6%AC%A1%E4%B8%8D%E8%83%BD%E5%8F%98%E6%88%90%E4%B8%80%E6%AC%A1%EF%BC%9F"><span class="toc-number">4.</span> <span class="toc-text">为什么4次挥手中间两次不能变成一次？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#TCP%E5%92%8CUDP%E7%9A%84%E5%8C%BA%E5%88%AB%E6%98%AF%E4%BB%80%E4%B9%88"><span class="toc-number">5.</span> <span class="toc-text">TCP和UDP的区别是什么</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#TCP%E7%9A%84%E6%8B%A5%E5%A1%9E%E6%8E%A7%E5%88%B6"><span class="toc-number">6.</span> <span class="toc-text">TCP的拥塞控制</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%8F%8F%E8%BF%B0%E4%B8%80%E4%B8%8B%E8%AE%BF%E9%97%AE%E4%B8%80%E4%B8%AAURL%E5%8F%91%E7%94%9F%E7%9A%84%E7%BD%91%E7%BB%9C%E8%BF%87%E7%A8%8B"><span class="toc-number">7.</span> <span class="toc-text">描述一下访问一个URL发生的网络过程</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#HTTP1-1%E5%92%8CHTTP2-0%E7%9A%84%E4%B8%BB%E8%A6%81%E5%8C%BA%E5%88%AB%E6%98%AF%E4%BB%80%E4%B9%88"><span class="toc-number">8.</span> <span class="toc-text">HTTP1.1和HTTP2.0的主要区别是什么</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#HTTP%E7%9A%84%E9%95%BF%E8%BF%9E%E6%8E%A5%E5%92%8C%E7%9F%AD%E8%BF%9E%E6%8E%A5"><span class="toc-number">9.</span> <span class="toc-text">HTTP的长连接和短连接</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#DNS%E5%9F%9F%E5%90%8D%E8%A7%A3%E6%9E%90%E7%9A%84%E5%B7%A5%E4%BD%9C%E6%B5%81%E7%A8%8B"><span class="toc-number">10.</span> <span class="toc-text">DNS域名解析的工作流程</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#token%EF%BC%8Csession%EF%BC%8Ccookie%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="toc-number">11.</span> <span class="toc-text">token，session，cookie的区别？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#JWT%E6%98%AF%E4%BB%80%E4%B9%88"><span class="toc-number">12.</span> <span class="toc-text">JWT是什么</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#token-session-cookie%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">13.</span> <span class="toc-text">token, session, cookie的区别</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#HTTP1-0%E5%88%B02-0%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">14.</span> <span class="toc-text">HTTP1.0到2.0的区别</span></a></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>Recent Posts</span></div><div class="aside-list"><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/05/09/Git-SSH%E5%AF%86%E9%92%A5%E9%85%8D%E7%BD%AE/" title="Git SSH密钥配置">Git SSH密钥配置</a><time datetime="2025-05-09T02:44:43.000Z" title="Created 2025-05-09 10:44:43">2025-05-09</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/04/30/%E6%89%8B%E5%8A%A8%E5%BC%80%E5%8F%91MCP%E9%A1%B9%E7%9B%AE/" title="手动开发MCP项目">手动开发MCP项目</a><time datetime="2025-04-30T05:56:05.000Z" title="Created 2025-04-30 13:56:05">2025-04-30</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/04/27/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E9%9D%A2%E8%AF%95%E9%A2%98-my/" title="计算机网络面试题(my)">计算机网络面试题(my)</a><time datetime="2025-04-27T12:56:41.000Z" title="Created 2025-04-27 20:56:41">2025-04-27</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/04/27/Java%E9%9D%A2%E8%AF%95%E7%AC%94%E8%AE%B0-my/" title="Java面试笔记(my)">Java面试笔记(my)</a><time datetime="2025-04-27T10:06:59.000Z" title="Created 2025-04-27 18:06:59">2025-04-27</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/04/26/%E6%B7%B1%E5%85%A5%E5%AD%A6%E4%B9%A0Go-Web%E5%BC%80%E5%8F%91%EF%BC%9AGin%E6%A1%86%E6%9E%B6%E4%BD%BF%E7%94%A8/" title="深入学习Go Web开发：Gin框架使用">深入学习Go Web开发：Gin框架使用</a><time datetime="2025-04-26T09:45:40.000Z" title="Created 2025-04-26 17:45:40">2025-04-26</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2019 - 2025 By XiWei</div><div class="framework-info"><span>Framework </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>Theme </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="Reading Mode"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="Toggle Between Light and Dark Mode"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="Toggle Between Single-column and Double-column"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="Settings"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="Table of Contents"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="Back to Top"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox/fancybox.umd.min.js"></script><div class="js-pjax"></div><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>