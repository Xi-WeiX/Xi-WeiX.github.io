<!DOCTYPE html><html lang="cn" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>Java面试笔记(my) | XiWei</title><meta name="author" content="XiWei"><meta name="copyright" content="XiWei"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="Java 中的 JIT 是什么？答案：  JIT (Just-In-Time) 是 Java 虚拟机 (JVM) 的即时编译器。 它的作用是在程序运行时将频繁执行的 Java 字节码动态编译成本地机器码。 这样做可以提高程序的执行速度，因为直接执行本地机器码比解释执行字节码更快。 JVM 会监控代码的“热点”，只对这些频繁执行的代码进行编译。  Java 中的垃圾回收机制是什么？答案：  垃圾回收">
<meta property="og:type" content="article">
<meta property="og:title" content="Java面试笔记(my)">
<meta property="og:url" content="https://xi-weix.github.io/2025/04/27/Java%E9%9D%A2%E8%AF%95%E7%AC%94%E8%AE%B0-my/index.html">
<meta property="og:site_name" content="XiWei">
<meta property="og:description" content="Java 中的 JIT 是什么？答案：  JIT (Just-In-Time) 是 Java 虚拟机 (JVM) 的即时编译器。 它的作用是在程序运行时将频繁执行的 Java 字节码动态编译成本地机器码。 这样做可以提高程序的执行速度，因为直接执行本地机器码比解释执行字节码更快。 JVM 会监控代码的“热点”，只对这些频繁执行的代码进行编译。  Java 中的垃圾回收机制是什么？答案：  垃圾回收">
<meta property="og:locale">
<meta property="og:image" content="https://xi-weix.github.io/img/%E9%9B%AA%E8%8A%B1.png">
<meta property="article:published_time" content="2025-04-27T10:06:59.000Z">
<meta property="article:modified_time" content="2025-04-28T06:41:24.757Z">
<meta property="article:author" content="XiWei">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://xi-weix.github.io/img/%E9%9B%AA%E8%8A%B1.png"><script type="application/ld+json">{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "Java面试笔记(my)",
  "url": "https://xi-weix.github.io/2025/04/27/Java%E9%9D%A2%E8%AF%95%E7%AC%94%E8%AE%B0-my/",
  "image": "https://xi-weix.github.io/img/%E9%9B%AA%E8%8A%B1.png",
  "datePublished": "2025-04-27T10:06:59.000Z",
  "dateModified": "2025-04-28T06:41:24.757Z",
  "author": [
    {
      "@type": "Person",
      "name": "XiWei",
      "url": "https://xi-weix.github.io/"
    }
  ]
}</script><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="https://xi-weix.github.io/2025/04/27/Java%E9%9D%A2%E8%AF%95%E7%AC%94%E8%AE%B0-my/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox/fancybox.min.css" media="print" onload="this.media='all'"><script>
    (() => {
      
    const saveToLocal = {
      set: (key, value, ttl) => {
        if (!ttl) return
        const expiry = Date.now() + ttl * 86400000
        localStorage.setItem(key, JSON.stringify({ value, expiry }))
      },
      get: key => {
        const itemStr = localStorage.getItem(key)
        if (!itemStr) return undefined
        const { value, expiry } = JSON.parse(itemStr)
        if (Date.now() > expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return value
      }
    }

    window.btf = {
      saveToLocal,
      getScript: (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        Object.entries(attr).forEach(([key, val]) => script.setAttribute(key, val))
        script.onload = script.onreadystatechange = () => {
          if (!script.readyState || /loaded|complete/.test(script.readyState)) resolve()
        }
        script.onerror = reject
        document.head.appendChild(script)
      }),
      getCSS: (url, id) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onload = link.onreadystatechange = () => {
          if (!link.readyState || /loaded|complete/.test(link.readyState)) resolve()
        }
        link.onerror = reject
        document.head.appendChild(link)
      }),
      addGlobalFn: (key, fn, name = false, parent = window) => {
        if (!false && key.startsWith('pjax')) return
        const globalFn = parent.globalFn || {}
        globalFn[key] = globalFn[key] || {}
        globalFn[key][name || Object.keys(globalFn[key]).length] = fn
        parent.globalFn = globalFn
      }
    }
  
      
      const activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      const activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }

      btf.activateDarkMode = activateDarkMode
      btf.activateLightMode = activateLightMode

      const theme = saveToLocal.get('theme')
    
          theme === 'dark' ? activateDarkMode() : theme === 'light' ? activateLightMode() : null
        
      
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        document.documentElement.classList.toggle('hide-aside', asideStatus === 'hide')
      }
    
      
    const detectApple = () => {
      if (/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)) {
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
  
    })()
  </script><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: undefined,
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false,"highlightFullpage":false,"highlightMacStyle":false},
  copy: {
    success: 'Copy Successful',
    error: 'Copy Failed',
    noSupport: 'Browser Not Supported'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  dateSuffix: {
    just: 'Just now',
    min: 'minutes ago',
    hour: 'hours ago',
    day: 'days ago',
    month: 'months ago'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  infinitegrid: {
    js: 'https://cdn.jsdelivr.net/npm/@egjs/infinitegrid/dist/infinitegrid.min.js',
    buttonText: 'Load More'
  },
  isPhotoFigcaption: false,
  islazyloadPlugin: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'Java面试笔记(my)',
  isHighlightShrink: false,
  isToc: true,
  pageType: 'post'
}</script><meta name="generator" content="Hexo 7.3.0"></head><body><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url(/img/beach.jpeg);"><nav id="nav"><span id="blog-info"><a class="nav-site-title" href="/"><img class="site-icon" src="/img/%E9%9B%AA%E8%8A%B1.png" alt="Logo"><span class="site-name">XiWei</span></a><a class="nav-page-title" href="/"><span class="site-name">Java面试笔记(my)</span></a></span><div id="menus"></div></nav><div id="post-info"><h1 class="post-title">Java面试笔记(my)</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">Created</span><time class="post-meta-date-created" datetime="2025-04-27T10:06:59.000Z" title="Created 2025-04-27 18:06:59">2025-04-27</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">Updated</span><time class="post-meta-date-updated" datetime="2025-04-28T06:41:24.757Z" title="Updated 2025-04-28 14:41:24">2025-04-28</time></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title=""><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">Post Views:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="container post-content" id="article-container"><h4 id="Java-中的-JIT-是什么？"><a href="#Java-中的-JIT-是什么？" class="headerlink" title="Java 中的 JIT 是什么？"></a><strong>Java 中的 JIT 是什么？</strong></h4><p><strong>答案：</strong></p>
<ul>
<li>JIT (Just-In-Time) 是 Java 虚拟机 (JVM) 的<strong>即时编译器</strong>。</li>
<li>它的作用是在程序<strong>运行时</strong>将<strong>频繁执行</strong>的 Java <strong>字节码</strong>动态编译成<strong>本地机器码</strong>。</li>
<li>这样做可以<strong>提高程序的执行速度</strong>，因为直接执行本地机器码比解释执行字节码更快。</li>
<li>JVM 会监控代码的“热点”，只对这些频繁执行的代码进行编译。</li>
</ul>
<h4 id="Java-中的垃圾回收机制是什么？"><a href="#Java-中的垃圾回收机制是什么？" class="headerlink" title="Java 中的垃圾回收机制是什么？"></a><strong>Java 中的垃圾回收机制是什么？</strong></h4><p><strong>答案：</strong></p>
<ul>
<li>垃圾回收 (Garbage Collection, GC) 是 Java 自动进行<strong>内存管理</strong>的机制。</li>
<li>它的主要目的是<strong>自动回收不再被使用的对象所占用的内存</strong>，防止内存泄漏。</li>
<li>基本过程：<ol>
<li><strong>标记：</strong> 找出所有仍然被引用的“存活”对象。</li>
<li><strong>清除&#x2F;回收：</strong> 将未被标记为“存活”的对象视为垃圾并回收其内存。</li>
</ol>
</li>
<li>常见算法（简化记忆）：<ul>
<li><strong>标记-清除：</strong> 标记存活，清除未标记（可能产生碎片）。</li>
<li><strong>复制：</strong> 将存活对象复制到另一区域（需要额外空间）。</li>
<li><strong>标记-整理：</strong> 标记存活，移动存活对象并清理边界外空间（开销较大）。</li>
<li><strong>分代收集：</strong> 根据对象生命周期分为新生代和老年代，采用不同算法优化回收。</li>
</ul>
</li>
</ul>
<h4 id="Java的优势是什么？"><a href="#Java的优势是什么？" class="headerlink" title="Java的优势是什么？"></a>Java的优势是什么？</h4><p><strong>答案：</strong></p>
<p><strong>平台无关性 (Platform Independence)：</strong></p>
<ul>
<li>“一次编写，到处运行 (Write Once, Run Anywhere - WORA)”。Java 代码被编译成字节码，可以在任何安装了 Java 虚拟机 (JVM) 的操作系统上运行，无需重新编译。</li>
</ul>
<p><strong>面向对象 (Object-Oriented)：</strong></p>
<ul>
<li>Java 是一种纯粹的面向对象编程语言，支持封装、继承和多态等 OOP 核心概念，有助于开发模块化、可维护和可扩展的应用程序。</li>
</ul>
<p><strong>内存管理 (Memory Management)：</strong></p>
<ul>
<li>拥有自动垃圾回收机制 (Garbage Collection)，开发者无需手动管理内存的分配和释放，降低了内存泄漏和程序崩溃的风险。</li>
</ul>
<p><strong>丰富的类库 (Rich Standard Library)：</strong></p>
<ul>
<li>提供了庞大且功能强大的标准类库 (Java API)，涵盖了各种常用的功能，如输入&#x2F;输出、网络、集合、并发等，可以快速开发应用程序。</li>
</ul>
<p><strong>强大的社区支持 (Large and Active Community)：</strong></p>
<ul>
<li>拥有庞大而活跃的开发者社区，提供了丰富的学习资源、开源框架和工具，遇到问题时更容易找到解决方案。</li>
</ul>
<p><strong>成熟的生态系统 (Mature Ecosystem)：</strong></p>
<ul>
<li>经过多年的发展，Java 拥有成熟且庞大的生态系统，包括各种优秀的框架（如 Spring、Hibernate）、工具和应用服务器（如 Tomcat、Jetty），适用于各种规模的企业级应用开发。</li>
</ul>
<p><strong>多线程支持 (Multithreading Support)：</strong></p>
<ul>
<li>Java 内置了强大的多线程支持，方便开发并发应用程序，提高程序的响应性和资源利用率。</li>
</ul>
<p>劣势的话，性能可能是一个，虽然JVM优化了很多，但相比C++或者Rust这种原生编译语言，还是有一定开销。特别是启动时间，比如微服务场景下，可能不如Go之类的快。语法繁琐，比如样板代码多，之前没有lambda的时候更麻烦，现在有了但比起Python还是不够简洁。内存消耗，JVM本身占内存，对于资源有限的环境可能不太友好。还有面向对象过于严格，有时候写简单程序反而麻烦，虽然Java8引入了函数式编程，但不如其他语言自然。还有开发效率，相比动态语言如Python，Java需要更多代码，编译过程也可能拖慢开发节奏。</p>
<h4 id="什么是Java的AOT"><a href="#什么是Java的AOT" class="headerlink" title="什么是Java的AOT"></a>什么是Java的AOT</h4><p>AOT (Ahead-Of-Time) 编译是一种在程序<strong>运行之前</strong>将 Java 字节码<strong>直接编译</strong>成特定平台（操作系统和硬件架构）的<strong>本地机器码</strong>的技术。这与传统的 JIT (Just-In-Time) 编译形成对比，后者是在程序运行时动态地编译热点代码。</p>
<p><strong>AOT 的主要特点和目标：</strong></p>
<ul>
<li><strong>提前编译：</strong> 编译发生在应用程序部署或安装时，而不是在运行时。</li>
<li><strong>生成本地代码：</strong> 产出的是可以直接被操作系统执行的机器码。</li>
<li><strong>更快的启动时间：</strong> 由于代码在运行前已经编译好，应用程序可以几乎立即启动，避免了 JVM 的预热和 JIT 编译的延迟。</li>
<li><strong>更低的内存占用：</strong> 运行时不需要 JVM 进行编译，可以减少 JVM 本身带来的内存开销。</li>
<li><strong>即时达到峰值性能：</strong> 避免了 JIT 编译需要时间来识别和优化热点代码的过程，理论上启动后就能达到较高的性能。</li>
<li><strong>可能生成更小的部署包：</strong> 一些 AOT 实现可以将应用程序及其依赖打包成一个独立的本地可执行文件。</li>
</ul>
<p><strong>需要注意的方面：</strong></p>
<ul>
<li><strong>编译时间较长：</strong> AOT 编译通常比 JIT 编译花费更多的时间，因为它需要在程序运行前分析和生成所有必要的本地代码。</li>
<li><strong>平台依赖性：</strong> AOT 编译生成的本地代码是特定于平台的，这意味着你需要为每个目标平台构建不同的可执行文件。</li>
<li><strong>可能损失一些 JIT 的动态优化能力：</strong> JIT 编译器可以在运行时根据实际的程序行为进行更精细的优化，而 AOT 编译器则需要在编译时进行静态分析，可能无法捕捉到所有的运行时信息。</li>
<li><strong>对 Java 的动态特性支持有限：</strong> 某些 Java 的动态特性（如反射、动态代理等）在 AOT 编译中可能需要额外的配置或受到限制，因为编译器需要在构建时就确定所有需要用到的类和方法。</li>
</ul>
<h4 id="Java面向对象编程和面向过程编程的区别是什么"><a href="#Java面向对象编程和面向过程编程的区别是什么" class="headerlink" title="Java面向对象编程和面向过程编程的区别是什么"></a>Java面向对象编程和面向过程编程的区别是什么</h4><p>面向对象编程 (OOP) 和面向过程编程是两种主要的编程范式，它们在组织代码和解决问题的方式上有着根本的区别。Java 是一种纯粹的面向对象编程语言。</p>
<p><strong>核心思想：</strong></p>
<ul>
<li><strong>面向过程 (Procedural Programming)：</strong> 将程序视为一系列<strong>按顺序执行的步骤或过程 (procedures)</strong>。关注的是**“做什么 (what to do)”**，将问题分解为一系列函数，通过函数调用来完成任务。数据通常是全局的，函数可以修改这些全局数据。</li>
<li><strong>面向对象 (Object-Oriented Programming)：</strong> 将程序视为一组相互<strong>交互的对象 (objects)</strong> 的集合。关注的是**“谁来做 (who does what)”<strong>，将问题分解为各种对象，每个对象拥有自己的</strong>数据（属性或状态）<strong>和</strong>行为（方法或函数）**。对象之间通过消息传递进行交互。</li>
</ul>
<p><strong>主要区别：</strong></p>
<ul>
<li>组织方式：<ul>
<li><strong>面向过程：</strong> 以函数为基本的组织单元，程序由一系列函数调用组成。</li>
<li><strong>面向对象：</strong> 以对象为基本的组织单元，对象包含数据和操作数据的行为。</li>
</ul>
</li>
<li>关注点：<ul>
<li><strong>面向过程：</strong> 侧重于算法和解决问题的步骤。</li>
<li><strong>面向对象：</strong> 侧重于对象及其属性和行为，以及对象之间的关系。</li>
</ul>
</li>
<li>数据处理：<ul>
<li><strong>面向过程：</strong> 数据通常是全局的，容易被不同的函数修改，可能导致数据不一致。</li>
<li><strong>面向对象：</strong> 数据通常封装在对象内部（通过访问修饰符控制访问），对象的行为（方法）负责修改自身的数据，提高了数据的安全性和一致性。</li>
</ul>
</li>
<li>可维护性：<ul>
<li><strong>面向过程：</strong> 当需求发生变化时，可能需要修改多个函数，代码的维护和修改较为困难。</li>
<li><strong>面向对象：</strong> 通过封装、继承和多态等特性，使得代码更模块化，修改一个对象的影响范围较小，提高了代码的可维护性和可扩展性。</li>
</ul>
</li>
<li>可重用性：<ul>
<li><strong>面向过程：</strong> 函数的重用性可能不高，因为函数通常针对特定的过程设计。</li>
<li><strong>面向对象：</strong> 通过创建类和对象，可以方便地重用已有的对象和类，提高了代码的重用性。</li>
</ul>
</li>
<li>抽象性：<ul>
<li><strong>面向过程：</strong> 抽象层次通常是函数级别的。</li>
<li><strong>面向对象：</strong> 可以通过类和接口实现更高层次的抽象，更好地模拟现实世界中的实体和关系。</li>
</ul>
</li>
<li>适用场景：<ul>
<li><strong>面向过程：</strong> 适用于解决规模较小、逻辑简单的、不需要过多交互的问题，例如一些科学计算、嵌入式系统等。</li>
<li><strong>面向对象：</strong> 更适用于解决规模较大、逻辑复杂、需要模拟现实世界实体和交互的应用，例如企业级应用、图形用户界面、游戏开发等。</li>
</ul>
</li>
</ul>
<p><strong>Java 的特点：</strong></p>
<p>由于 Java 是一种纯粹的面向对象语言，因此它强制开发者采用面向对象的思想进行编程，提供了丰富的特性来支持 OOP，例如类、对象、封装、继承、多态、接口等。虽然 Java 中也有方法（类似于面向过程中的函数），但方法总是属于某个类或对象。</p>
<p>总而言之，面向对象编程通过模拟现实世界中的对象和它们之间的交互，提供了一种更自然、更灵活、更易于维护和扩展的软件开发方式，这使得它在现代软件开发中占据主导地位。而 Java 作为一种面向对象的语言，其设计理念和语法都深刻地体现了 OOP 的思想。</p>
<h4 id="简单介绍介绍Java的封装继承多态"><a href="#简单介绍介绍Java的封装继承多态" class="headerlink" title="简单介绍介绍Java的封装继承多态"></a>简单介绍介绍Java的封装继承多态</h4><p>封装、继承和多态是面向对象编程 (OOP) 的三大基本特征，它们是构建可维护、可复用和可扩展软件的重要基石。在 Java 中，这三个概念得到了很好的支持。</p>
<p><strong>封装 (Encapsulation)：</strong></p>
<ul>
<li><strong>核心思想：</strong> 将<strong>数据（属性）和操作这些数据的行为（方法）捆绑在一起，形成一个独立的单元（类）。同时，通过访问修饰符</strong>（如 <code>public</code>、<code>private</code>、<code>protected</code>）控制对内部数据和方法的访问级别。</li>
<li>目的：<ul>
<li><strong>信息隐藏：</strong> 隐藏对象的内部实现细节，只暴露必要的接口给外部使用，提高了安全性。</li>
<li><strong>模块化：</strong> 将对象视为独立的模块，降低了代码的耦合度。</li>
<li><strong>可维护性：</strong> 当对象的内部实现发生改变时，只要接口不变，就不会影响到使用该对象的代码。</li>
</ul>
</li>
</ul>
<p><strong>继承 (Inheritance)：</strong></p>
<ul>
<li><strong>核心思想：</strong> 子类可以<strong>继承</strong>父类的属性和方法，从而无需从头开始定义新的类。通过 <code>extends</code> 关键字实现。</li>
<li>目的：<ul>
<li><strong>代码重用：</strong> 避免重复编写相同的代码，提高了开发效率。</li>
<li><strong>可扩展性：</strong> 可以通过继承创建新的类，扩展已有类的功能。</li>
<li><strong>维护性：</strong> 修改父类的属性和方法，所有子类都会受到影响，便于统一维护。</li>
</ul>
</li>
<li>特点：<ul>
<li>Java 只支持<strong>单继承</strong>（一个类只能直接继承一个父类），但可以通过<strong>接口</strong>实现多重继承的效果。</li>
</ul>
</li>
</ul>
<p><strong>多态 (Polymorphism)：</strong></p>
<ul>
<li><strong>核心思想：</strong> 指允许<strong>不同类的对象对同一消息做出不同的响应</strong>。同一个接口，使用不同的实例而执行不同的操作。</li>
<li>实现方式：<ul>
<li><strong>编译时多态（静态多态）：</strong> 方法重载 (Overloading)。在同一个类中定义了多个方法名相同但参数列表不同的方法。编译器在编译时根据参数列表确定调用哪个方法。</li>
<li><strong>运行时多态（动态多态）：</strong> 方法重写 (Overriding)。子类重写了父类的方法，在运行时根据对象的实际类型（而不是声明类型）来决定调用哪个方法。需要满足继承关系和方法签名相同（返回类型、方法名、参数列表）的条件。</li>
</ul>
</li>
<li>目的：<ul>
<li><strong>灵活性和可扩展性：</strong> 允许以统一的方式处理不同类型的对象。</li>
<li><strong>代码的抽象性：</strong> 可以编写更通用的代码，提高代码的抽象层次。</li>
<li><strong>可维护性：</strong> 当需要添加新的子类时，只需要重写相关方法即可，无需修改原有的代码。</li>
</ul>
</li>
</ul>
<p>总而言之，封装隐藏了实现细节，提高了安全性和可维护性；继承实现了代码的重用和扩展；多态则提高了代码的灵活性和抽象性。这三大特性共同构成了面向对象编程的基础，使得 Java 能够构建复杂、健壮且易于维护的应用程序。</p>
<h4 id="Java的继承和C-的继承有什么区别"><a href="#Java的继承和C-的继承有什么区别" class="headerlink" title="Java的继承和C++的继承有什么区别"></a>Java的继承和C++的继承有什么区别</h4><p>Java 的继承和 C++ 的继承虽然都是面向对象编程中实现代码重用和扩展的重要机制，但在实现方式和特性上存在一些关键的区别。</p>
<p><strong>主要区别：</strong></p>
<ol>
<li><strong>单继承 vs. 多重继承：</strong><ul>
<li><strong>Java：</strong> 只支持<strong>单继承</strong>，一个类只能直接继承一个父类（使用 <code>extends</code> 关键字）。为了实现类似多重继承的功能，Java 引入了<strong>接口 (interface)</strong> 机制，一个类可以实现多个接口。</li>
<li><strong>C++：</strong> 支持<strong>多重继承</strong>，一个类可以同时继承多个父类。这提供了更大的灵活性，但也可能导致一些复杂的问题，如菱形继承（diamond problem）和命名冲突。</li>
</ul>
</li>
<li><strong>接口 (Interface)：</strong><ul>
<li><strong>Java：</strong> 接口是一种完全抽象的类型，只能包含抽象方法（在 JDK 8 之前）和常量。从 JDK 8 开始，接口可以包含默认方法和静态方法。接口主要用于定义行为规范，实现类必须实现接口中定义的所有抽象方法。一个类可以实现多个接口。</li>
<li><strong>C++：</strong> 没有明确的 <code>interface</code> 关键字。可以通过包含纯虚函数的抽象类来实现类似接口的功能。C++ 的类可以同时继承多个包含具体实现的基类。</li>
</ul>
</li>
<li><strong>构造函数和析构函数：</strong><ul>
<li><strong>Java：</strong> 子类的构造函数必须显式或隐式地调用父类的构造函数（使用 <code>super()</code>）。Java 拥有自动垃圾回收机制，没有显式的析构函数。对象的清理工作由垃圾回收器负责。</li>
<li><strong>C++：</strong> 子类的构造函数可以使用初始化列表显式调用父类的构造函数。C++ 拥有析构函数（<code>~ClassName()</code>），用于在对象生命周期结束时执行清理操作，例如释放内存。需要程序员手动管理对象的生命周期。</li>
</ul>
</li>
<li><strong>方法重写 (Overriding)：</strong><ul>
<li><strong>Java：</strong> 子类重写父类方法时，可以使用 <code>@Override</code> 注解进行标记，方便编译器检查是否正确重写。默认情况下，非 <code>final</code> 和非 <code>static</code> 的方法可以被重写。</li>
<li><strong>C++：</strong> 子类重写父类虚函数时，可以使用 <code>override</code> 关键字（C++11 引入）进行标记。父类中需要使用 <code>virtual</code> 关键字声明的方法才能被子类重写。</li>
</ul>
</li>
<li><strong>访问修饰符：</strong><ul>
<li><strong>Java：</strong> 提供 <code>public</code>、<code>protected</code>、<code>private</code> 和默认（包访问权限）四种访问修饰符，用于控制类成员的可见性。</li>
<li><strong>C++：</strong> 提供 <code>public</code>、<code>protected</code> 和 <code>private</code> 三种访问修饰符，以及友元 (friend) 机制，允许特定的类或函数访问类的私有和保护成员。</li>
</ul>
</li>
<li><strong>继承方式的控制：</strong><ul>
<li><strong>Java：</strong> 继承是默认的，如果不想被继承，可以使用 <code>final</code> 关键字修饰类。如果不想被重写，可以使用 <code>final</code> 关键字修饰方法。</li>
<li><strong>C++：</strong> 在继承时可以指定继承方式（<code>public</code>、<code>protected</code>、<code>private</code>），这会影响基类成员在派生类中的访问权限。</li>
</ul>
</li>
<li><strong>菱形继承问题：</strong><ul>
<li><strong>Java：</strong> 通过单继承和接口的方式避免了多重继承可能带来的菱形继承问题。接口之间可以继承，如果继承了相同的方法签名，实现类需要提供自己的实现。</li>
<li><strong>C++：</strong> 由于支持多重继承，可能出现菱形继承问题。C++ 提供了虚继承（<code>virtual inheritance</code>）来解决这个问题，确保派生类只有一个共享的基类实例。</li>
</ul>
</li>
<li><strong>设计哲学：</strong><ul>
<li><strong>Java：</strong> 设计上更强调简单性和安全性，通过单继承和接口、自动内存管理等机制简化了编程模型，降低了出错的可能性。</li>
<li><strong>C++：</strong> 提供了更多的灵活性和底层控制能力，允许进行多重继承和手动内存管理，但也增加了编程的复杂性和潜在的风险。</li>
</ul>
</li>
</ol>
<h4 id="Java的Exception和Error对比"><a href="#Java的Exception和Error对比" class="headerlink" title="Java的Exception和Error对比"></a>Java的Exception和Error对比</h4><p>在 Java 中，<code>Exception</code> 和 <code>Error</code> 都是 <code>java.lang.Throwable</code> 类的子类，它们代表了程序执行过程中发生的异常情况。然而，它们之间存在着重要的区别，理解这些区别对于编写健壮的 Java 应用程序至关重要。</p>
<p><strong>主要区别：</strong></p>
<ol>
<li><p><strong>继承关系：</strong></p>
<ul>
<li><pre><code>java.lang.Object
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">- ```</span><br><span class="line">  java.lang.Throwable</span><br></pre></td></tr></table></figure>

  - `java.lang.Exception`
  - `java.lang.Error`
</code></pre>
</li>
</ul>
</li>
<li><p><strong>性质和预期处理方式：</strong></p>
<ul>
<li>Exception（异常）：指的是程序在正常运行过程中可能发生的、可预料的问题。这些问题通常可以通过程序自身的逻辑来捕获、处理或恢复。例如：<ul>
<li><code>IOException</code> (输入&#x2F;输出异常)</li>
<li><code>SQLException</code> (SQL 异常)</li>
<li><code>NullPointerException</code> (空指针异常 - 虽然是运行时异常，但通常是可以通过代码避免的)</li>
<li><code>ArrayIndexOutOfBoundsException</code> (数组索引越界异常 - 同样通常可以通过代码避免)</li>
<li><code>ClassNotFoundException</code> (类未找到异常)</li>
</ul>
</li>
<li>Error（错误）：指的是通常发生在JVM 内部、操作系统级别或者硬件层面的严重问题。这些问题通常超出应用程序的控制范围，并且无法通过程序代码来恢复。一旦发生 Error，通常会导致程序终止。例如：<ul>
<li><code>OutOfMemoryError</code> (内存溢出错误)</li>
<li><code>StackOverflowError</code> (栈溢出错误)</li>
<li><code>VirtualMachineError</code> (虚拟机错误，如内部错误、版本不兼容等)</li>
<li><code>NoClassDefFoundError</code> (类定义未找到错误 - 通常是由于类在编译时存在，但在运行时不可用)</li>
<li><code>LinkageError</code> (链接错误，如类文件格式错误、依赖关系错误等)</li>
</ul>
</li>
</ul>
</li>
<li><p><strong>处理机制：</strong></p>
<ul>
<li><strong>Exception：</strong> Java 强制要求处理<strong>已检查异常 (Checked Exception)</strong>（除了 <code>RuntimeException</code> 及其子类）。开发者必须使用 <code>try-catch</code> 块捕获并处理这些异常，或者在方法签名中使用 <code>throws</code> 声明该方法可能抛出的已检查异常，将其传递给调用者处理。<strong>未检查异常 (Unchecked Exception)</strong>（即 <code>RuntimeException</code> 及其子类）通常是由程序逻辑错误引起的，虽然不强制要求捕获，但良好的编程习惯仍然建议进行处理或至少进行预防。</li>
<li><strong>Error：</strong> 通常<strong>不应该</strong>尝试使用 <code>try-catch</code> 块来捕获 <code>Error</code>。因为 <code>Error</code> 代表的是系统级的严重问题，即使捕获了也很难或无法恢复，继续运行可能会导致更不可预测的行为。遇到 <code>Error</code> 时，通常应该记录错误信息并让程序优雅地终止。</li>
</ul>
</li>
</ol>
<p><strong>总结：</strong></p>
<table>
<thead>
<tr>
<th><strong>特征</strong></th>
<th><strong>Exception (异常)</strong></th>
<th><strong>Error (错误)</strong></th>
</tr>
</thead>
<tbody><tr>
<td><strong>性质</strong></td>
<td>程序运行中可能发生的、可预料的问题</td>
<td>JVM、操作系统或硬件层面的严重问题，超出程序控制</td>
</tr>
<tr>
<td><strong>预期处理</strong></td>
<td>应该捕获和处理（特别是已检查异常），或进行预防</td>
<td>通常不应捕获，应记录并让程序终止</td>
</tr>
<tr>
<td><strong>发生范围</strong></td>
<td>应用程序级别</td>
<td>系统级别、JVM 级别</td>
</tr>
<tr>
<td><strong>恢复可能</strong></td>
<td>通常可以通过程序逻辑处理或恢复</td>
<td>很难或无法通过程序代码恢复</td>
</tr>
<tr>
<td><strong>强制处理</strong></td>
<td>已检查异常强制处理，未检查异常建议处理或预防</td>
<td>不强制处理（通常也无法有效处理）</td>
</tr>
</tbody></table>
<h4 id="JDK，JVM，JRE的关系"><a href="#JDK，JVM，JRE的关系" class="headerlink" title="JDK，JVM，JRE的关系"></a>JDK，JVM，JRE的关系</h4><p><img src="/2025/04/27/Java%E9%9D%A2%E8%AF%95%E7%AC%94%E8%AE%B0-my/Snipaste_2025-04-28_14-19-41.png"></p>
<ul>
<li>JVM是Java虚拟机，是Java程序运行的环境。它负责将Java字节码（由Java编译器生成）解释或编译成机器码，并执行程序。JVM提供了内存管理、垃圾回收、安全性等功能，使得Java程序具备跨平台性。</li>
<li>JDK是Java开发工具包，是开发Java程序所需的工具集合。它包含了JVM、编译器（javac）、调试器（jdb）等开发工具，以及一系列的类库（如Java标准库和开发工具库）。JDK提供了开发、编译、调试和运行Java程序所需的全部工具和环境。</li>
<li>JRE是Java运行时环境，是Java程序运行所需的最小环境。它包含了JVM和一组Java类库，用于支持Java程序的执行。JRE不包含开发工具，只提供Java程序运行所需的运行环境。</li>
</ul>
<h4 id="深拷贝与浅拷贝的区别"><a href="#深拷贝与浅拷贝的区别" class="headerlink" title="深拷贝与浅拷贝的区别"></a>深拷贝与浅拷贝的区别</h4><p><img src="/2025/04/27/Java%E9%9D%A2%E8%AF%95%E7%AC%94%E8%AE%B0-my/Snipaste_2025-04-28_14-33-31.png"></p>
<ul>
<li>浅拷贝是指只复制对象本身和其内部的值类型字段，但不会复制对象内部的引用类型字段。换句话说，浅拷贝只是创建一个新的对象，然后将原对象的字段值复制到新对象中，但如果原对象内部有引用类型的字段，只是将引用复制到新对象中，两个对象指向的是同一个引用对象。</li>
<li>深拷贝是指在复制对象的同时，将对象内部的所有引用类型字段的内容也复制一份，而不是共享引用。换句话说，深拷贝会递归复制对象内部所有引用类型的字段，生成一个全新的对象以及其内部的所有对象。</li>
</ul>
<h4 id="什么是反射"><a href="#什么是反射" class="headerlink" title="什么是反射"></a>什么是反射</h4><p>反射 (Reflection) 是指在<strong>运行时</strong>检查、访问和修改<strong>类、接口、字段和方法</strong>等结构的能力，而无需在<strong>编译时</strong>知道这些类的确切名字或结构。简单来说，反射允许程序在运行过程中“审视自身”并根据运行时获取的信息动态地操作程序的组成部分。</p>
<p><strong>Java 反射机制的核心：</strong></p>
<p>Java 的反射机制主要由 <code>java.lang.reflect</code> 包中的类和接口提供，最核心的类是 <code>Class</code>。</p>
<ul>
<li><strong>Class 类：</strong> 代表一个类或接口的运行时类型信息。通过 <code>Class</code> 对象，你可以获取到类的名称、修饰符（public, private 等）、实现的接口、继承的父类、所有的字段、所有的方法、所有的构造器等信息。每个加载到 JVM 中的类都有一个对应的 <code>Class</code> 实例。</li>
</ul>
<p><strong>获取 Class 对象的方式：</strong></p>
<ol>
<li><strong>使用 Class.forName(“类的完整限定名”)：</strong> 这是最常用的方式，通过类的全限定名（包名 + 类名）在运行时动态加载类并获取其 <code>Class</code> 对象。如果类不存在或初始化失败，会抛出 <code>ClassNotFoundException</code> 或 <code>ExceptionInInitializerError</code>。</li>
<li><strong>使用对象的 getClass() 方法：</strong> 如果你已经拥有一个类的实例对象，可以调用该对象的 <code>getClass()</code> 方法来获取其 <code>Class</code> 对象。</li>
<li><strong>使用类字面常量 ClassName.class：</strong> 如果在编译时就知道类名，可以使用类字面常量来获取 <code>Class</code> 对象，这种方式不会触发类的初始化。</li>
<li><strong>基本数据类型包装类的 TYPE 字段：</strong> 例如 <code>Integer.TYPE</code> 可以获取 <code>int</code> 类型的 <code>Class</code> 对象。</li>
</ol>
<p><strong>通过 Class 对象可以进行的操作：</strong></p>
<p>一旦获取到 <code>Class</code> 对象，就可以利用 <code>java.lang.reflect</code> 包中的其他类和接口进行以下操作：</p>
<ul>
<li>获取类的基本信息：<ul>
<li><code>getName()</code>：获取类的完整限定名。</li>
<li><code>getSimpleName()</code>：获取类的简单名称。</li>
<li><code>getModifiers()</code>：获取类的修饰符（返回一个整数，可以使用 <code>Modifier</code> 类的方法解析）。</li>
<li><code>getInterfaces()</code>：获取类实现的接口。</li>
<li><code>getSuperclass()</code>：获取类的父类。</li>
<li><code>getPackage()</code>：获取类所在的包。</li>
</ul>
</li>
<li>操作类的字段 (<code>Field</code> 类)：<ul>
<li><code>getFields()</code>：获取所有公共 (public) 的字段。</li>
<li><code>getDeclaredFields()</code>：获取所有声明的字段（包括 private, protected, public）。</li>
<li><code>getField(String name)</code> &#x2F; <code>getDeclaredField(String name)</code>：获取指定名称的字段。</li>
<li><code>get()</code>：获取字段的值。</li>
<li><code>set()</code>：设置字段的值。</li>
<li>可以访问和修改对象的私有字段（需要调用 <code>setAccessible(true)</code> 禁用访问控制）。</li>
</ul>
</li>
<li>操作类的方法 (<code>Method</code> 类)：<ul>
<li><code>getMethods()</code>：获取所有公共 (public) 的方法，包括继承自父类的方法。</li>
<li><code>getDeclaredMethods()</code>：获取所有声明的方法（包括 private, protected, public）。</li>
<li><code>getMethod(String name, Class&lt;?&gt;... parameterTypes)</code> &#x2F; <code>getDeclaredMethod(String name, Class&lt;?&gt;... parameterTypes)</code>：获取指定名称和参数类型的方法。</li>
<li><code>invoke(Object obj, Object... args)</code>：调用方法。</li>
<li>可以调用对象的私有方法（需要调用 <code>setAccessible(true)</code> 禁用访问控制）。</li>
</ul>
</li>
<li>操作类的构造器 (<code>Constructor</code> 类)：<ul>
<li><code>getConstructors()</code>：获取所有公共 (public) 的构造器。</li>
<li><code>getDeclaredConstructors()</code>：获取所有声明的构造器（包括 private, protected, public）。</li>
<li><code>getConstructor(Class&lt;?&gt;... parameterTypes)</code> &#x2F; <code>getDeclaredConstructor(Class&lt;?&gt;... parameterTypes)</code>：获取指定参数类型的构造器。</li>
<li><code>newInstance(Object... initargs)</code>：使用指定的参数创建类的新的实例。</li>
<li>可以调用私有构造器创建对象（需要调用 <code>setAccessible(true)</code> 禁用访问控制）。</li>
</ul>
</li>
<li>创建类的实例：<ul>
<li><code>newInstance()</code>：调用类的无参公共构造器创建实例。</li>
</ul>
</li>
</ul>
<p><strong>反射的应用场景：</strong></p>
<ul>
<li><strong>框架开发：</strong> 许多 Java 框架（如 Spring、Hibernate）大量使用反射来实现依赖注入、对象关系映射等功能，使得框架具有高度的灵活性和可配置性。</li>
<li><strong>动态代理：</strong> Java 的动态代理机制基于反射实现，可以在运行时创建接口的代理对象。</li>
<li><strong>单元测试：</strong> 某些测试框架可以使用反射来访问和测试类的私有方法和字段。</li>
<li><strong>IDE 和工具：</strong> 集成开发环境和一些工具可以使用反射来分析类的结构，提供代码提示、自动完成等功能。</li>
<li><strong>序列化和反序列化：</strong> 一些序列化库使用反射来获取对象的字段信息。</li>
<li><strong>通用性编程：</strong> 编写更加通用的代码，可以处理不同类型的对象，而无需在编译时知道具体的类型。</li>
</ul>
<p><strong>反射的缺点：</strong></p>
<ul>
<li><strong>性能开销：</strong> 反射操作通常比直接的代码调用要慢，因为它涉及到运行时的类型检查和动态方法调用等。频繁使用反射可能会影响程序的性能。</li>
<li><strong>安全风险：</strong> 反射可以访问和修改类的私有成员，可能会破坏类的封装性，带来安全风险。</li>
<li><strong>可维护性降低：</strong> 过度使用反射可能会使代码变得难以理解和维护，因为程序的行为不是在编译时确定的，而是依赖于运行时的元数据。</li>
</ul>
<p><strong>总结：</strong></p>
<p>反射是 Java 语言的一个强大特性，它赋予了程序在运行时动态地检查和操作自身结构的能力。虽然反射带来了灵活性和通用性，但在性能和安全性方面需要谨慎使用。通常情况下，只有在必要的时候（例如开发框架、工具等）才应该考虑使用反射。</p>
<h4 id="什么是线程安全"><a href="#什么是线程安全" class="headerlink" title="什么是线程安全"></a>什么是线程安全</h4><p>线程安全 (Thread Safety) 指的是当多个线程<strong>并发访问</strong>（即同时访问）一个共享的资源（例如数据、对象、代码块）时，<strong>无论这些线程如何交错执行，该资源都能保持其数据的一致性和预期的行为，不会出现竞态条件 (Race Condition) 或其他并发问题</strong>。</p>
<p>简单来说，一个代码块、方法或类是线程安全的，如果它在多线程环境下能够正确地处理共享资源，而不需要额外的同步机制（例如锁）。</p>
<p><strong>线程不安全的情况通常会导致以下问题：</strong></p>
<ul>
<li><strong>竞态条件 (Race Condition)：</strong> 多个线程竞争访问和修改共享资源，导致程序的最终结果依赖于线程执行的特定顺序，产生意想不到的错误。</li>
<li><strong>数据不一致性 (Data Inconsistency)：</strong> 多个线程对共享数据进行修改，由于没有适当的同步控制，导致数据处于不正确的状态。</li>
<li><strong>死锁 (Deadlock)：</strong> 多个线程互相持有对方需要的资源，导致所有线程都无法继续执行。</li>
</ul>
<p><strong>实现线程安全的方法：</strong></p>
<p>为了使代码或资源在多线程环境下安全地工作，需要采取一些同步措施，常见的手段包括：</p>
<ul>
<li>互斥同步 (Mutual Exclusion)：<ul>
<li><strong>锁 (Locks)：</strong> 使用锁机制（例如 Java 中的 <code>synchronized</code> 关键字和 <code>java.util.concurrent.locks.Lock</code> 接口的实现类）来保证在同一时刻只有一个线程可以访问被保护的共享资源。</li>
</ul>
</li>
<li>非阻塞同步 (Non-blocking Synchronization)：<ul>
<li><strong>原子操作 (Atomic Operations)：</strong> 使用原子类（例如 <code>java.util.concurrent.atomic</code> 包下的类）提供的原子性操作，这些操作在执行过程中不会被中断。</li>
<li><strong>Compare-and-Swap (CAS)：</strong> 一种无锁算法，尝试将一个变量的值原子性地更新为新值，但只有在当前值与期望值相等时才执行更新。</li>
</ul>
</li>
<li>线程封闭 (Thread Confinement)：<ul>
<li>将共享资源限制在单个线程内部访问，避免多个线程之间的竞争。例如，使用线程局部变量 (<code>ThreadLocal</code>) 为每个线程创建独立的资源副本。</li>
</ul>
</li>
<li>不可变性 (Immutability)：<ul>
<li>将对象设计为不可变 (Immutable)，一旦创建后其状态就不能被修改。由于状态不可变，多个线程可以安全地并发访问不可变对象而无需同步。</li>
</ul>
</li>
</ul>
<p><strong>判断线程安全性的标准：</strong></p>
<p>一个类或方法在以下情况下被认为是线程安全的：</p>
<ul>
<li><strong>原子性 (Atomicity)：</strong> 涉及共享资源的操作序列必须作为一个不可分割的单元执行，中间不能被其他线程中断。</li>
<li><strong>可见性 (Visibility)：</strong> 当一个线程修改了共享变量的值时，其他线程能够及时地看到这个修改。</li>
<li><strong>有序性 (Ordering)：</strong> 程序代码的执行顺序可能与代码的字面顺序不一致（由于指令重排序），但在单线程环境下和正确同步的多线程环境下，程序的执行结果应该是一致的。</li>
</ul>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta"><i class="fas fa-circle-user fa-fw"></i>Author: </span><span class="post-copyright-info"><a href="https://xi-weix.github.io">XiWei</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta"><i class="fas fa-square-arrow-up-right fa-fw"></i>Link: </span><span class="post-copyright-info"><a href="https://xi-weix.github.io/2025/04/27/Java%E9%9D%A2%E8%AF%95%E7%AC%94%E8%AE%B0-my/">https://xi-weix.github.io/2025/04/27/Java%E9%9D%A2%E8%AF%95%E7%AC%94%E8%AE%B0-my/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta"><i class="fas fa-circle-exclamation fa-fw"></i>Copyright Notice: </span><span class="post-copyright-info">All articles on this blog are licensed under <a target="_blank" rel="noopener" href="https://creativecommons.org/licenses/by-nc-sa/4.0/">CC BY-NC-SA 4.0</a> unless otherwise stated.</span></div></div><div class="tag_share"><div class="post-share"><div class="social-share" data-image="/img/%E9%9B%AA%E8%8A%B1.png" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"></nav></div><div class="aside-content" id="aside-content"><div class="card-widget card-info text-center"><div class="avatar-img"><img src="/img/%E9%9B%AA%E8%8A%B1.png" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info-name">XiWei</div><div class="author-info-description"></div><div class="site-data"><a href="/archives/"><div class="headline">Articles</div><div class="length-num">23</div></a><a href="/tags/"><div class="headline">Tags</div><div class="length-num">1</div></a><a href="/categories/"><div class="headline">Categories</div><div class="length-num">0</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/Xi-WeiX"><i class="fab fa-github"></i><span>Follow Me</span></a></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>Announcement</span></div><div class="announcement_content">This is my Blog</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>Contents</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-4"><a class="toc-link" href="#Java-%E4%B8%AD%E7%9A%84-JIT-%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="toc-number">1.</span> <span class="toc-text">Java 中的 JIT 是什么？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Java-%E4%B8%AD%E7%9A%84%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E6%9C%BA%E5%88%B6%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="toc-number">2.</span> <span class="toc-text">Java 中的垃圾回收机制是什么？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Java%E7%9A%84%E4%BC%98%E5%8A%BF%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="toc-number">3.</span> <span class="toc-text">Java的优势是什么？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AFJava%E7%9A%84AOT"><span class="toc-number">4.</span> <span class="toc-text">什么是Java的AOT</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Java%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A8%8B%E5%92%8C%E9%9D%A2%E5%90%91%E8%BF%87%E7%A8%8B%E7%BC%96%E7%A8%8B%E7%9A%84%E5%8C%BA%E5%88%AB%E6%98%AF%E4%BB%80%E4%B9%88"><span class="toc-number">5.</span> <span class="toc-text">Java面向对象编程和面向过程编程的区别是什么</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%AE%80%E5%8D%95%E4%BB%8B%E7%BB%8D%E4%BB%8B%E7%BB%8DJava%E7%9A%84%E5%B0%81%E8%A3%85%E7%BB%A7%E6%89%BF%E5%A4%9A%E6%80%81"><span class="toc-number">6.</span> <span class="toc-text">简单介绍介绍Java的封装继承多态</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Java%E7%9A%84%E7%BB%A7%E6%89%BF%E5%92%8CC-%E7%9A%84%E7%BB%A7%E6%89%BF%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB"><span class="toc-number">7.</span> <span class="toc-text">Java的继承和C++的继承有什么区别</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Java%E7%9A%84Exception%E5%92%8CError%E5%AF%B9%E6%AF%94"><span class="toc-number">8.</span> <span class="toc-text">Java的Exception和Error对比</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#JDK%EF%BC%8CJVM%EF%BC%8CJRE%E7%9A%84%E5%85%B3%E7%B3%BB"><span class="toc-number">9.</span> <span class="toc-text">JDK，JVM，JRE的关系</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%B7%B1%E6%8B%B7%E8%B4%9D%E4%B8%8E%E6%B5%85%E6%8B%B7%E8%B4%9D%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">10.</span> <span class="toc-text">深拷贝与浅拷贝的区别</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E5%8F%8D%E5%B0%84"><span class="toc-number">11.</span> <span class="toc-text">什么是反射</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8"><span class="toc-number">12.</span> <span class="toc-text">什么是线程安全</span></a></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>Recent Posts</span></div><div class="aside-list"><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/05/09/Git-SSH%E5%AF%86%E9%92%A5%E9%85%8D%E7%BD%AE/" title="Git SSH密钥配置">Git SSH密钥配置</a><time datetime="2025-05-09T02:44:43.000Z" title="Created 2025-05-09 10:44:43">2025-05-09</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/04/30/%E6%89%8B%E5%8A%A8%E5%BC%80%E5%8F%91MCP%E9%A1%B9%E7%9B%AE/" title="手动开发MCP项目">手动开发MCP项目</a><time datetime="2025-04-30T05:56:05.000Z" title="Created 2025-04-30 13:56:05">2025-04-30</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/04/27/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E9%9D%A2%E8%AF%95%E9%A2%98-my/" title="计算机网络面试题(my)">计算机网络面试题(my)</a><time datetime="2025-04-27T12:56:41.000Z" title="Created 2025-04-27 20:56:41">2025-04-27</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/04/27/Java%E9%9D%A2%E8%AF%95%E7%AC%94%E8%AE%B0-my/" title="Java面试笔记(my)">Java面试笔记(my)</a><time datetime="2025-04-27T10:06:59.000Z" title="Created 2025-04-27 18:06:59">2025-04-27</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/04/26/%E6%B7%B1%E5%85%A5%E5%AD%A6%E4%B9%A0Go-Web%E5%BC%80%E5%8F%91%EF%BC%9AGin%E6%A1%86%E6%9E%B6%E4%BD%BF%E7%94%A8/" title="深入学习Go Web开发：Gin框架使用">深入学习Go Web开发：Gin框架使用</a><time datetime="2025-04-26T09:45:40.000Z" title="Created 2025-04-26 17:45:40">2025-04-26</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2019 - 2025 By XiWei</div><div class="framework-info"><span>Framework </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>Theme </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="Reading Mode"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="Toggle Between Light and Dark Mode"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="Toggle Between Single-column and Double-column"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="Settings"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="Table of Contents"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="Back to Top"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox/fancybox.umd.min.js"></script><div class="js-pjax"></div><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>